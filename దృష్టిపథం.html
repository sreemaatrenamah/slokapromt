<!DOCTYPE html>
<html lang="te">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a73e8">
    <meta name="description" content="Smooth cursor-based Sanskrit sloka reader with customizable fonts, colors, and reading speeds">
    <title>‡∞¶‡±É‡∞∑‡±ç‡∞ü‡∞ø‡∞™‡∞•‡∞Ç</title>
    <link rel="manifest" href="./manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'><rect fill='%231a73e8' width='192' height='192'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-size='100' fill='white' font-family='Arial' font-weight='bold'>üìñ</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'><rect fill='%231a73e8' width='180' height='180' rx='40'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-size='90' fill='white' font-family='Arial' font-weight='bold'>üìñ</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=NTR&display=swap" rel="stylesheet">
    
    <style>
        :root { --bg-color: #f4f7f6; --text-color: #111111; --cursor-color: #1a73e8; --font-size: 42px; }
        
        /* Responsive font sizing */
        @media (max-width: 768px) {
            :root { --font-size: 28px; }
        }
        @media (max-width: 480px) {
            :root { --font-size: 22px; }
        }
        body { font-family: 'NTR', sans-serif; background: var(--bg-color); color: var(--text-color); margin: 0; overflow-x: hidden; }
        .settings-container { width: 90%; max-width: 850px; margin: 20px auto; background: white; padding: 25px; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
        body.reading-active .settings-container { display: none; }
        textarea { width: 100%; min-height: 180px; margin-bottom: 20px; padding: 15px; font-size: 18px; border: 2px solid #e0e0e0; border-radius: 10px; }
        .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .option-group { background: #fdfdfd; padding: 12px; border-radius: 10px; border: 1px solid #eee; display: flex; flex-direction: column; gap: 8px; }
        
        /* The container MUST be position: relative for the cursor to align to it */
        .sloka-container { position: relative; width: 100%; max-width: 800px; margin: 0 auto 40px; opacity: 0; transition: opacity 0.5s blur; filter: blur(0px); }
        .sloka-container.visible { opacity: 1; }
        .sloka-container.fade-out { opacity: 0; filter: blur(8px); }
        
        .line-row { display: block; white-space: normal; word-wrap: break-word; margin-bottom: 16px; min-height: 1.2em; position: relative; }
        .char-span { font-size: var(--font-size); display: inline-block; white-space: pre; line-height: 1.4; position: relative; }
        
        #displayArea { display: none; justify-content: center; align-items: center; min-height: 100vh; padding: 10vh 20px; box-sizing: border-box; }
        body.reading-active #displayArea { display: flex; padding-top: calc(10vh + 60px); }
        
        #globalCursor { 
            position: absolute; height: 6px; width: 35px; background: var(--cursor-color);
            border-radius: 3px; z-index: 100;
            pointer-events: none;
        }

        .slider-group { display: flex; align-items: center; gap: 10px; }
        .slider-group input[type="range"] { flex: 1; }
        .slider-group .value-display { min-width: 35px; font-weight: bold; color: var(--text-color); }

        .color-controls { display: flex; gap: 10px; align-items: center; }
        .color-controls input[type="color"] { width: 50px; height: 40px; border: none; border-radius: 6px; cursor: pointer; }

        #displayArea.scroll-mode { display: flex; flex-direction: column; padding: 40px 20px; overflow-y: hidden; height: 100vh; justify-content: flex-start; align-items: center; }
        #displayArea.scroll-mode .sloka-container { margin-bottom: 40px; opacity: 1 !important; animation: pageBlurIn 0.5s ease-in-out; }

        @keyframes pageBlurIn {
            0% {
                opacity: 0;
                filter: blur(10px);
            }
            100% {
                opacity: 1;
                filter: blur(0px);
            }
        }

        /* Rolling Mode styles */
        #displayArea.rolling-mode { display: flex; flex-direction: column; justify-content: center; align-items: center; overflow: hidden; position: relative; height: 100vh; }
        .rolling-container { position: absolute; width: 100%; text-align: center; white-space: pre-wrap; word-wrap: break-word; left: 0; right: 0; transition: none; will-change: transform; transform: translateZ(0); backface-visibility: hidden; }
        .rolling-line { font-size: var(--font-size); margin: 0.6em 0; line-height: 1.4; color: var(--text-color); padding: 0 20px; white-space: pre-wrap; }
        .rolling-line.empty { margin: 1.2em 0; }

        #stopBtn { position: fixed; bottom: 30px; right: 30px; background: #ea4335; color: white; border: none; padding: 15px 30px; border-radius: 50px; cursor: pointer; display: none; z-index: 1000; opacity: 0; transition: opacity 0.3s ease; pointer-events: auto; }
        body.reading-active #stopBtn { display: block; }
        body.reading-active.show-reset #stopBtn { opacity: 1; }
        
        /* Watermark branding */
        #branding-watermark { position: fixed; top: 20px; right: 30px; z-index: 999; text-align: center; font-family: 'NTR', sans-serif; line-height: 1.3; pointer-events: none; letter-spacing: 0.5px; }
        #branding-watermark.hidden { display: none; }
        .branding-line { font-size: 16px; font-weight: bold; }
        .branding-line:first-child { font-size: 18px; }
    </style>
</head>
<body>

<div class="settings-container">
    <h2 style="text-align:center;">‡∞¶‡±É‡∞∑‡±ç‡∞ü‡∞ø‡∞™‡∞•‡∞Ç 2026</h2>
    <textarea id="textInput">
‡∞∂‡±Å‡∞ï‡±ç‡∞≤‡∞æ‡∞Ç ‡∞¨‡∞∞‡∞ß‡∞∞‡∞Ç-‡∞µ‡∞ø‡∞Ä‡∞∑‡±ç‡∞£‡±Å‡∞Ç ‡∞∂‡∞∂‡∞ø‡∞µ‡∞∞‡±ç‡∞£‡∞Ç ‡∞ö‡∞§‡±Å‡∞∞‡±ç‡∞≠‡±Å‡∞ú‡∞Æ‡±ç ‡•§
‡∞™‡±ç‡∞∞‡∞∏‡∞®‡±ç‡∞®‡∞µ‡∞¶‡∞®‡∞Ç ‡∞ß‡±ç‡∞Ø‡∞æ‡∞Ø‡±á‡∞§‡±ç ‡∞∏‡∞∞‡±ç‡∞µ ‡∞µ‡∞ø‡∞ò‡±ç‡∞®‡±ã‡∞™‡∞∂‡∞æ‡∞Ç‡∞§‡∞Ø‡±á
‡∞Ø‡∞∏‡±ç‡∞Ø‡∞¶‡±ç‡∞µ‡∞ø‡∞∞‡∞¶ ‡∞µ‡∞ï‡±ç‡∞§‡±ç‡∞∞‡∞æ‡∞¶‡±ç‡∞Ø‡∞æ‡∞É ‡∞™‡∞æ‡∞∞‡∞ø‡∞∑‡∞¶‡±ç‡∞Ø‡∞æ‡∞É ‡∞™‡∞∞‡∞∂‡±ç‡∞∂‡∞§‡∞Æ‡±ç ‡•§
‡∞µ‡∞ø‡∞ò‡±ç‡∞®‡∞Ç ‡∞®‡∞ø‡∞ò‡±ç‡∞®‡∞Ç‡∞§‡±Å ‡∞∏‡∞§‡∞§‡∞Ç-‡∞µ‡∞ø‡∞Ä‡∞∑‡±ç‡∞µ‡∞ï‡±ç‡∞∏‡±á‡∞®‡∞Ç ‡∞§‡∞Æ‡∞æ‡∞∂‡±ç‡∞∞‡∞Ø‡±á ‡••

‡∞∂‡±Å‡∞ï‡±ç‡∞≤‡∞æ‡∞Ç ‡∞¨‡∞∞‡∞ß‡∞∞‡∞Ç-‡∞µ‡∞ø‡∞Ä‡∞∑‡±ç‡∞£‡±Å‡∞Ç ‡∞∂‡∞∂‡∞ø‡∞µ‡∞∞‡±ç‡∞£‡∞Ç ‡∞ö‡∞§‡±Å‡∞∞‡±ç‡∞≠‡±Å‡∞ú‡∞Æ‡±ç ‡•§
‡∞™‡±ç‡∞∞‡∞∏‡∞®‡±ç‡∞®‡∞µ‡∞¶‡∞®‡∞Ç ‡∞ß‡±ç‡∞Ø‡∞æ‡∞Ø‡±á‡∞§‡±ç ‡∞∏‡∞∞‡±ç‡∞µ ‡∞µ‡∞ø‡∞ò‡±ç‡∞®‡±ã‡∞™‡∞∂‡∞æ‡∞Ç‡∞§‡∞Ø‡±á
‡∞Ø‡∞∏‡±ç‡∞Ø‡∞¶‡±ç‡∞µ‡∞ø‡∞∞‡∞¶ ‡∞µ‡∞ï‡±ç‡∞§‡±ç‡∞∞‡∞æ‡∞¶‡±ç‡∞Ø‡∞æ‡∞É ‡∞™‡∞æ‡∞∞‡∞ø‡∞∑‡∞¶‡±ç‡∞Ø‡∞æ‡∞É ‡∞™‡∞∞‡∞∂‡±ç‡∞∂‡∞§‡∞Æ‡±ç ‡•§
‡∞µ‡∞ø‡∞ò‡±ç‡∞®‡∞Ç ‡∞®‡∞ø‡∞ò‡±ç‡∞®‡∞Ç‡∞§‡±Å ‡∞∏‡∞§‡∞§‡∞Ç-‡∞µ‡∞ø‡∞Ä‡∞∑‡±ç‡∞µ‡∞ï‡±ç‡∞∏‡±á‡∞®‡∞Ç ‡∞§‡∞Æ‡∞æ‡∞∂‡±ç‡∞∞‡∞Ø‡±á ‡••

</textarea>
    <div class="controls">
        <div class="option-group"><span>Mode</span>
            <select id="modeSelect">
                <option value="unifocus">UniFocus Mode</option>
                <option value="scroll" selected>Continuous Mode</option>
                <option value="rolling">Rolling Mode</option>
            </select>
        </div>
        <div class="option-group">
            <span>Font Size</span>
            <div class="slider-group">
                <input type="range" id="fontSizeControl" min="16" max="80" value="42">
                <span class="value-display" id="fontSizeValue">42</span>
            </div>
        </div>
        <div class="option-group">
            <span>Speed</span>
            <div class="slider-group">
                <input type="range" id="speedControl" min="0.5" max="12" step="0.5" value="1">
                <span class="value-display" id="speedValue">1</span>
            </div>
        </div>
        <div class="option-group">
            <span>Colors</span>
            <div class="color-controls">
                <input type="color" id="bgPicker" value="#f4f7f6" title="Background Color">
                <input type="color" id="textPicker" value="#111111" title="Text Color">
                <input type="color" id="cursorPicker" value="#1a73e8" title="Cursor Color">
            </div>
        </div>
        <div class="option-group">
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="showBranding" checked style="cursor: pointer;">
                <span>Show Branding</span>
            </label>
        </div>
    </div>
    <button onclick="startReading()" style="width:100%; padding:15px; background:#34a853; color:white; border:none; border-radius:8px; cursor:pointer;">Start Reading</button>
</div>

<button id="stopBtn" onclick="stopReading()">Reset</button>
<div id="branding-watermark">
    <div class="branding-line">#AI‡∞∂‡±Ä‡∞®‡±Å</div>
    <div class="branding-line">instagram/norisrinivasa</div>
</div>
<div id="displayArea"></div>

<script>
    let slokas = [], currentSlokaIdx = 0, isReading = false, charTimeout = null, wakeLock = null;
    let resetRevealTimeout = null;
    let readingStartTime = 0;
    const segmenter = new Intl.Segmenter('te', { granularity: 'grapheme' });

    // Screen Wake Lock Management for phones
    async function acquireWakeLock() {
        try {
            if ('wakeLock' in navigator && isReading) {
                wakeLock = await navigator.wakeLock.request('screen');
                log.info('Screen wake lock acquired');
            }
        } catch (err) {
            log.warn('Failed to acquire wake lock', err);
        }
    }

    async function releaseWakeLock() {
        try {
            if (wakeLock) {
                await wakeLock.release();
                wakeLock = null;
                log.info('Screen wake lock released');
            }
        } catch (err) {
            log.warn('Failed to release wake lock', err);
        }
    }

    // Logging system
    const log = {
        info: (msg, data = null) => {
            console.log(`[INFO] ${new Date().toISOString().substr(11, 12)} - ${msg}`, data || '');
        },
        debug: (msg, data = null) => {
            console.debug(`[DEBUG] ${new Date().toISOString().substr(11, 12)} - ${msg}`, data || '');
        },
        error: (msg, data = null) => {
            console.error(`[ERROR] ${new Date().toISOString().substr(11, 12)} - ${msg}`, data || '');
        },
        warn: (msg, data = null) => {
            console.warn(`[WARN] ${new Date().toISOString().substr(11, 12)} - ${msg}`, data || '');
        }
    };

    // Calculate luminance of a color to determine contrast
    function getLuminance(hexColor) {
        const rgb = parseInt(hexColor.slice(1), 16);
        const r = (rgb >> 16) & 0xff;
        const g = (rgb >> 8) & 0xff;
        const b = (rgb >> 0) & 0xff;
        return 0.299 * r + 0.587 * g + 0.114 * b;
    }

    log.info('Application initialized');
    log.debug('Segmenter created for Telugu', { granularity: 'grapheme' });

    function parseSlokas(text) {
        log.debug('Parsing slokas from text', { textLength: text.length });
        
        // Split by || or double newlines
        let parts = text.split(/\|\||\n\s*\n/);
        const result = parts
            .map(part => part.trim())
            .filter(part => part.length > 0)
            .map(part => part.split('\n'));
            
        log.info('Slokas parsed successfully', { count: result.length, totalLines: result.reduce((sum, sloka) => sum + sloka.length, 0) });
        return result;
    }

    function startReading() {
        const text = document.getElementById('textInput').value.trim();
        if (!text) {
            log.warn('Start reading called with empty text');
            return;
        }

        log.info('Starting reading session');
        
        // Update CSS variables from color pickers
        const bgColor = document.getElementById('bgPicker').value;
        const textColor = document.getElementById('textPicker').value;
        const cursorColor = document.getElementById('cursorPicker').value;
        const fontSize = document.getElementById('fontSizeControl').value;
        
        document.documentElement.style.setProperty('--bg-color', bgColor);
        document.documentElement.style.setProperty('--text-color', textColor);
        document.documentElement.style.setProperty('--cursor-color', cursorColor);
        document.documentElement.style.setProperty('--font-size', fontSize + 'px');
        document.body.style.background = bgColor;
        document.body.style.color = textColor;
        
        // Set branding color - contrasting to background
        const brandingEl = document.getElementById('branding-watermark');
        const isLightBg = getLuminance(bgColor) > 128;
        brandingEl.style.color = isLightBg ? '#000000' : '#FFFFFF';
        
        // Show/hide branding based on toggle
        const showBranding = document.getElementById('showBranding').checked;
        if (showBranding) {
            brandingEl.classList.remove('hidden');
        } else {
            brandingEl.classList.add('hidden');
        }
        
        log.debug('UI settings applied', { bgColor, textColor, cursorColor, fontSize });

        const mode = document.getElementById('modeSelect').value;
        log.info('Reading mode selected', { mode });
        
        readingStartTime = Date.now();

        if (mode === 'unifocus') {
            slokas = parseSlokas(text);
            currentSlokaIdx = 0;
            isReading = true;
            document.body.classList.add('reading-active');
            document.getElementById('displayArea').classList.remove('scroll-mode');
            document.getElementById('displayArea').classList.remove('rolling-mode');
            log.info('Starting UniFocus mode');
            renderSloka();
        } else if (mode === 'scroll') {
            // Continuous scroll mode
            slokas = parseSlokas(text);
            currentSlokaIdx = 0;
            isReading = true;
            document.body.classList.add('reading-active');
            document.getElementById('displayArea').classList.add('scroll-mode');
            document.getElementById('displayArea').classList.remove('rolling-mode');
            log.info('Starting Continuous mode');
            renderScrollMode();
        } else if (mode === 'rolling') {
            // Rolling credits mode
            isReading = true;
            document.body.classList.add('reading-active');
            document.getElementById('displayArea').classList.remove('scroll-mode');
            document.getElementById('displayArea').classList.add('rolling-mode');
            log.info('Starting Rolling mode');
            acquireWakeLock();
            renderRollingMode(text);
        }
    }

    function renderSloka() {
        if (!isReading || currentSlokaIdx >= slokas.length) {
            log.info('Rendering complete or stopped', { isReading, currentSlokaIdx, totalSlokas: slokas.length });
            return stopReading();
        }

        log.debug('Rendering sloka', { index: currentSlokaIdx, total: slokas.length });
        
        const mode = document.getElementById('modeSelect').value;
        const area = document.getElementById('displayArea');
        
        // Fade out previous sloka if it exists
        const existing = area.querySelector('.sloka-container');
        if (existing) {
            log.debug('Fading out previous sloka');
            existing.classList.add('fade-out');
            setTimeout(() => {
                area.innerHTML = '';
                renderSlokaContent();
            }, 500);
        } else {
            area.innerHTML = '';
            renderSlokaContent();
        }
    }

    function renderSlokaContent() {
        const area = document.getElementById('displayArea');
        const container = document.createElement('div');
        container.className = 'sloka-container';

        const charSequence = [];
        const sloka = slokas[currentSlokaIdx];
        
        log.debug('Rendering sloka content', { slokaLines: sloka.length });

        sloka.forEach((line, lIdx) => {
            const row = document.createElement('div');
            row.className = 'line-row';
            
            // Handle empty lines (spacing between slokas)
            if (line.trim() === "") {
                row.style.height = "1.5em";
                container.appendChild(row);
                log.debug('Added empty line', { lineIndex: lIdx });
            } else {
                const segments = Array.from(segmenter.segment(line));
                log.debug('Processing line', { lineIndex: lIdx, segments: segments.length });
                
                segments.forEach((seg, sIdx) => {
                    const span = document.createElement('span');
                    span.className = 'char-span';
                    span.id = `c-${lIdx}-${sIdx}`;
                    span.textContent = seg.segment;
                    row.appendChild(span);
                    charSequence.push({ id: span.id, lineIdx: lIdx });
                });
                container.appendChild(row);
            }
        });

        area.appendChild(container);
        log.info('Sloka content rendered', { totalChars: charSequence.length });
        
        setTimeout(() => {
            container.classList.add('visible');
            animateCursor(charSequence, container);
        }, 100);
    }

    function animateCursor(sequence, container) {
        if (!isReading || sequence.length === 0) {
            releaseWakeLock();
            setTimeout(() => {
                currentSlokaIdx++;
                renderSloka();
            }, 1000);
            return;
        }
        
        // Acquire wake lock for cursor movement
        acquireWakeLock();

        // Create or reuse fixed positioned cursor
        let cursor = document.getElementById('globalCursor');
        if (!cursor) {
            cursor = document.createElement('div');
            cursor.id = 'globalCursor';
            cursor.style.position = 'fixed';
            cursor.style.height = '6px';
            cursor.style.width = '35px';
            cursor.style.borderRadius = '3px';
            cursor.style.zIndex = '100';
            cursor.style.pointerEvents = 'none';
            document.body.appendChild(cursor);
        }

        // Pre-calculate all character positions, only counting distances within lines
        const charPositions = [];
        const distances = [0];
        
        for (let i = 0; i < sequence.length; i++) {
            const charEl = document.getElementById(sequence[i].id);
            if (charEl) {
                const charRect = charEl.getBoundingClientRect();
                charPositions.push({
                    left: charRect.left,
                    top: charRect.bottom - 4
                });
                
                if (i > 0) {
                    const prev = charPositions[i - 1];
                    const curr = charPositions[i];
                    
                    // Only count distance if on same line (Y difference < 5px)
                    if (Math.abs(curr.top - prev.top) <= 5) {
                        const dx = curr.left - prev.left;
                        const distance = Math.abs(dx);
                        distances.push(distances[i - 1] + distance);
                    } else {
                        // New line: distance resets to 0 (no wait at line beginning)
                        distances.push(distances[i - 1]);
                    }
                }
            }
        }

        if (charPositions.length === 0) {
            setTimeout(() => {
                currentSlokaIdx++;
                renderSloka();
            }, 1000);
            return;
        }

        const totalDistance = distances[distances.length - 1];
        const speedValue = parseInt(document.getElementById('speedControl').value);
        const pixelsPerSecond = 100 * speedValue;
        const totalDuration = (totalDistance / pixelsPerSecond) * 1000;
        const animationStartTime = performance.now();

        const updateCursorPosition = (currentTime) => {
            if (!isReading) return;

            const elapsed = currentTime - animationStartTime;
            const progress = Math.min(elapsed / totalDuration, 1);
            const targetDistance = progress * totalDistance;

            // Find which character segment we're in
            let segmentIdx = 0;
            for (let i = 0; i < distances.length - 1; i++) {
                if (targetDistance >= distances[i] && targetDistance < distances[i + 1]) {
                    segmentIdx = i;
                    break;
                }
            }
            if (targetDistance >= distances[distances.length - 1]) {
                segmentIdx = distances.length - 2;
            }

            const cursor = document.getElementById('globalCursor');
            if (cursor && charPositions.length > 0) {
                const nextIdx = Math.min(segmentIdx + 1, charPositions.length - 1);
                const current = charPositions[segmentIdx];
                const next = charPositions[nextIdx];
                
                // Check if crossing to a new line (instant vertical jump, no interpolation)
                const isNewLine = Math.abs(current.top - next.top) > 5;
                
                if (isNewLine) {
                    // Instantly jump to next line position, no wait
                    cursor.style.left = next.left + 'px';
                    cursor.style.top = next.top + 'px';
                } else {
                    // Same line - smooth horizontal interpolation only
                    const segmentDistance = distances[nextIdx] - distances[segmentIdx];
                    const segmentProgress = segmentDistance > 0 
                        ? (targetDistance - distances[segmentIdx]) / segmentDistance 
                        : 0;
                    
                    const interpolatedLeft = current.left + (next.left - current.left) * segmentProgress;
                    cursor.style.left = interpolatedLeft + 'px';
                    cursor.style.top = current.top + 'px';
                }
                cursor.style.background = getComputedStyle(document.documentElement).getPropertyValue('--cursor-color').trim();
            }

            if (progress < 1) {
                requestAnimationFrame(updateCursorPosition);
            } else {
                // Animation complete
                releaseWakeLock();
                setTimeout(() => {
                    currentSlokaIdx++;
                    renderSloka();
                }, 1000);
            }
        };

        requestAnimationFrame(updateCursorPosition);
    }

    function renderScrollMode() {
        const area = document.getElementById('displayArea');
        area.innerHTML = '';
        
        // Create single cursor for scroll mode
        const globalCursor = document.createElement('div');
        globalCursor.id = 'globalCursor';
        globalCursor.style.position = 'fixed';
        globalCursor.style.height = '6px';
        globalCursor.style.width = '35px';
        globalCursor.style.background = getComputedStyle(document.documentElement).getPropertyValue('--cursor-color').trim();
        globalCursor.style.borderRadius = '3px';
        globalCursor.style.zIndex = '100';
        globalCursor.style.pointerEvents = 'none';
        document.body.appendChild(globalCursor);

        const charSequence = [];

        slokas.forEach((sloka, sIdx) => {
            const container = document.createElement('div');
            container.className = 'sloka-container';
            container.id = `sloka-${sIdx}`;
            
            sloka.forEach((line, lIdx) => {
                const row = document.createElement('div');
                row.className = 'line-row';
                
                if (line.trim() === "") {
                    row.style.height = "1.5em";
                    container.appendChild(row);
                } else {
                    const segments = Array.from(segmenter.segment(line));
                    segments.forEach((seg, segIdx) => {
                        const span = document.createElement('span');
                        span.className = 'char-span';
                        span.id = `scroll-c-${sIdx}-${lIdx}-${segIdx}`;
                        span.textContent = seg.segment;
                        row.appendChild(span);
                        charSequence.push(span.id);
                    });
                    container.appendChild(row);
                }
            });
            area.appendChild(container);
        });

        setTimeout(() => {
            animateScrollCursor(charSequence);
        }, 100);
    }

    function animateScrollCursor(sequence) {
        if (!isReading || sequence.length === 0) {
            const cursor = document.getElementById('globalCursor');
            if (cursor) cursor.remove();
            releaseWakeLock();
            return stopReading();
        }
        
        // Acquire wake lock for cursor movement
        acquireWakeLock();

        // Pre-calculate all character positions, only counting distances within lines
        const charPositions = [];
        const distances = [0];
        
        for (let i = 0; i < sequence.length; i++) {
            const charEl = document.getElementById(sequence[i]);
            if (charEl) {
                const charRect = charEl.getBoundingClientRect();
                charPositions.push({
                    left: charRect.left,
                    top: charRect.bottom - 4
                });
                
                if (i > 0) {
                    const prev = charPositions[i - 1];
                    const curr = charPositions[i];
                    
                    // Only count distance if on same line (Y difference < 5px)
                    if (Math.abs(curr.top - prev.top) <= 5) {
                        const dx = curr.left - prev.left;
                        const distance = Math.abs(dx);
                        distances.push(distances[i - 1] + distance);
                    } else {
                        // New line: distance resets to 0 (no wait at line beginning)
                        distances.push(distances[i - 1]);
                    }
                }
            }
        }

        if (charPositions.length === 0) {
            const cursor = document.getElementById('globalCursor');
            if (cursor) cursor.remove();
            return stopReading();
        }

        const totalDistance = distances[distances.length - 1];
        const speedValue = parseInt(document.getElementById('speedControl').value);
        const pixelsPerSecond = 100 * speedValue; // Higher speed value = faster movement
        const totalDuration = (totalDistance / pixelsPerSecond) * 1000; // in milliseconds
        const animationStartTime = performance.now();

        const updateCursorPosition = (currentTime) => {
            if (!isReading) return;

            const elapsed = currentTime - animationStartTime;
            const progress = Math.min(elapsed / totalDuration, 1);
            const targetDistance = progress * totalDistance;

            // Find which character segment we're in
            let segmentIdx = 0;
            for (let i = 0; i < distances.length - 1; i++) {
                if (targetDistance >= distances[i] && targetDistance < distances[i + 1]) {
                    segmentIdx = i;
                    break;
                }
            }
            if (targetDistance >= distances[distances.length - 1]) {
                segmentIdx = distances.length - 2;
            }

            const cursor = document.getElementById('globalCursor');
            if (cursor && charPositions.length > 0) {
                const nextIdx = Math.min(segmentIdx + 1, charPositions.length - 1);
                const current = charPositions[segmentIdx];
                const next = charPositions[nextIdx];
                
                // Check if crossing to a new line (instant vertical jump, no interpolation)
                const isNewLine = Math.abs(current.top - next.top) > 5;
                
                if (isNewLine) {
                    // Instantly jump to next line position, no wait
                    cursor.style.left = next.left + 'px';
                    cursor.style.top = next.top + 'px';
                } else {
                    // Same line - smooth horizontal interpolation only
                    const segmentDistance = distances[nextIdx] - distances[segmentIdx];
                    const segmentProgress = segmentDistance > 0 
                        ? (targetDistance - distances[segmentIdx]) / segmentDistance 
                        : 0;
                    
                    const interpolatedLeft = current.left + (next.left - current.left) * segmentProgress;
                    cursor.style.left = interpolatedLeft + 'px';
                    cursor.style.top = current.top + 'px';
                }
                cursor.style.background = getComputedStyle(document.documentElement).getPropertyValue('--cursor-color').trim();
            }

            if (progress < 1) {
                requestAnimationFrame(updateCursorPosition);
            } else {
                // Animation complete
                const cursor = document.getElementById('globalCursor');
                if (cursor) cursor.remove();
                releaseWakeLock();
                stopReading();
            }
        };

        requestAnimationFrame(updateCursorPosition);
    }

    function renderRollingMode(text) {
        const area = document.getElementById('displayArea');
        area.innerHTML = '';
        
        // Parse text preserving all formatting including empty lines
        const lines = text.split('\n');
        log.debug('Rolling mode text parsed', { totalLines: lines.length });
        
        // Find the last non-empty line
        let lastNonEmptyIdx = -1;
        for (let i = lines.length - 1; i >= 0; i--) {
            if (lines[i].trim() !== '') {
                lastNonEmptyIdx = i;
                break;
            }
        }
        
        // Take the last 15 lines (or all if less than 15) to preserve all spacing before credits
        const creditBlockStart = Math.max(0, lastNonEmptyIdx - 14);
        
        const container = document.createElement('div');
        container.className = 'rolling-container';
        container.id = 'rolling-container';
        
        // Create line elements for all lines
        lines.forEach((line, idx) => {
            const lineDiv = document.createElement('div');
            lineDiv.className = 'rolling-line';
            lineDiv.id = `rolling-line-${idx}`;
            lineDiv.setAttribute('data-line-index', idx);
            
            if (line.trim() === '') {
                lineDiv.classList.add('empty');
                lineDiv.innerHTML = '&nbsp;'; // Use non-breaking space to preserve height
            } else {
                lineDiv.textContent = line;
            }
            
            container.appendChild(lineDiv);
        });
        
        area.appendChild(container);
        
        // Start position: container begins off-screen at the bottom
        container.style.transform = `translateY(${window.innerHeight}px) translateZ(0)`;
        
        // Calculate total height - wait for layout
        setTimeout(() => {
            const totalHeight = container.scrollHeight;
            const viewportHeight = window.innerHeight;
            
            // Find the position where the last non-empty line will be at center
            const lastLineEl = container.querySelector(`[data-line-index="${lastNonEmptyIdx}"]`);
            const lastLineOffsetTop = lastLineEl ? lastLineEl.offsetTop : totalHeight;
            const lastLineHeight = lastLineEl ? lastLineEl.offsetHeight : 0;
            
            log.debug('Rolling mode dimensions', { totalHeight, viewportHeight, creditBlockStart, lastNonEmptyIdx, lastLineOffsetTop });
            
            // Start animation: scroll from bottom until last line reaches center
            animateRollingCredits(container, totalHeight, viewportHeight, lastLineOffsetTop, lastLineHeight);
        }, 50);
    }

    function animateRollingCredits(container, totalHeight, viewportHeight, lastLineOffsetTop, lastLineHeight) {
        if (!isReading) return;
        
        const speedValue = parseInt(document.getElementById('speedControl').value);
        const pixelsPerSecond = 100 * speedValue;
        
        // Start: container at bottom (viewportHeight)
        // End: last line center aligned = container top at (viewportHeight/2 - lastLineOffsetTop - lastLineHeight/2)
        const startY = viewportHeight;
        const endY = (viewportHeight / 2) - lastLineOffsetTop - (lastLineHeight / 2);
        const totalScrollDistance = startY - endY;
        const duration = (totalScrollDistance / pixelsPerSecond) * 1000; // in ms
        const startTime = performance.now();
        
        log.debug('Rolling animation started', { startY, endY, totalDistance: totalScrollDistance, duration, speed: speedValue });
        
        const animate = (currentTime) => {
            if (!isReading) return;
            
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Linear scroll for rolling credits
            const currentY = startY - (totalScrollDistance * progress);
            // Round to prevent sub-pixel rendering causing shaking
            const roundedY = Math.round(currentY);
            container.style.transform = `translateY(${roundedY}px) translateZ(0)`;
            
            // Keep wake lock active while rolling
            if (!wakeLock && navigator.wakeLock) {
                acquireWakeLock();
            }
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - last line is centered
                container.style.transform = `translateY(${Math.round(endY)}px) translateZ(0)`;
                log.info('Rolling animation completed - last line centered');
                
                setTimeout(() => {
                    if (isReading) {
                        stopReading();
                    }
                }, 5000);
            }
        };
        
        requestAnimationFrame(animate);
    }
    
    function stopReading() {
        log.info('Stopping reading session', { currentSloka: currentSlokaIdx, wasReading: isReading });
        
        isReading = false;
        clearTimeout(charTimeout);
        document.body.classList.remove('reading-active');
        document.getElementById('displayArea').innerHTML = '';
        
        // Remove cursor element
        const cursor = document.getElementById('globalCursor');
        if (cursor) {
            cursor.remove();
            log.debug('Global cursor removed');
        }
        
        // Release screen wake lock
        releaseWakeLock();
        
        log.info('Reading session stopped successfully');
    }

    // Update font size in real-time with slider
    document.getElementById('fontSizeControl')?.addEventListener('input', (e) => {
        document.documentElement.style.setProperty('--font-size', e.target.value + 'px');
        document.getElementById('fontSizeValue').textContent = e.target.value;
        log.debug('Font size changed', { newSize: e.target.value });
    });

    // Update speed display
    document.getElementById('speedControl')?.addEventListener('input', (e) => {
        document.getElementById('speedValue').textContent = e.target.value;
        log.debug('Speed changed', { newSpeed: e.target.value });
    });

    // Update colors in real-time
    document.getElementById('bgPicker')?.addEventListener('input', (e) => {
        document.documentElement.style.setProperty('--bg-color', e.target.value);
        document.body.style.background = e.target.value;
        log.debug('Background color changed', { newColor: e.target.value });
        const brandingEl = document.getElementById('branding-watermark');
        const isLightBg = getLuminance(e.target.value) > 128;
        if (brandingEl) brandingEl.style.color = isLightBg ? '#000000' : '#FFFFFF';
    });

    document.getElementById('textPicker')?.addEventListener('input', (e) => {
        document.documentElement.style.setProperty('--text-color', e.target.value);
        document.body.style.color = e.target.value;
        log.debug('Text color changed', { newColor: e.target.value });
    });

    document.getElementById('cursorPicker')?.addEventListener('input', (e) => {
        document.documentElement.style.setProperty('--cursor-color', e.target.value);
        log.debug('Cursor color changed', { newColor: e.target.value });
    });

    function revealResetTemporarily() {
        if (!isReading) return;
        if (Date.now() - readingStartTime < 2000) return;
        document.body.classList.add('show-reset');
        if (resetRevealTimeout) {
            clearTimeout(resetRevealTimeout);
        }
        resetRevealTimeout = setTimeout(() => {
            document.body.classList.remove('show-reset');
        }, 2000);
    }

    // Show reset on any hover/touch during reading
    document.addEventListener('mousemove', revealResetTemporarily);
    document.addEventListener('touchstart', revealResetTemporarily, { passive: true });

    // Branding toggle
    document.getElementById('showBranding')?.addEventListener('change', (e) => {
        const brandingEl = document.getElementById('branding-watermark');
        if (e.target.checked) {
            brandingEl.classList.remove('hidden');
            log.debug('Branding shown');
        } else {
            brandingEl.classList.add('hidden');
            log.debug('Branding hidden');
        }
    });

    // Set responsive defaults on page load
    window.addEventListener('DOMContentLoaded', () => {
        const width = window.innerWidth;
        let defaultFontSize = 42;
        
        if (width <= 480) {
            defaultFontSize = 22;
        } else if (width <= 768) {
            defaultFontSize = 28;
        }
        
        document.getElementById('fontSizeControl').value = defaultFontSize;
        document.getElementById('fontSizeValue').textContent = defaultFontSize;
        document.documentElement.style.setProperty('--font-size', defaultFontSize + 'px');
        
        log.info('Responsive defaults set', { screenWidth: width, fontSize: defaultFontSize });
    });

    // Register Service Worker for PWA functionality
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js')
                .then((registration) => {
                    log.info('Service Worker registered successfully', { scope: registration.scope });
                })
                .catch((error) => {
                    log.error('Service Worker registration failed', error);
                });
        });
    } else {
        log.warn('Service Worker not supported in this browser');
    }

</script>
</body>
</html>
