<!DOCTYPE html>
<html lang="te">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a73e8">
    <meta name="description" content="Smooth cursor-based Sanskrit sloka reader with customizable fonts, colors, and reading speeds">
    <title>‡∞¶‡±É‡∞∑‡±ç‡∞ü‡∞ø‡∞™‡∞•‡∞Ç</title>
    <link rel="manifest" href="./manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'><rect fill='%231a73e8' width='192' height='192'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-size='100' fill='white' font-family='Arial' font-weight='bold'>üìñ</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'><rect fill='%231a73e8' width='180' height='180' rx='40'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-size='90' fill='white' font-family='Arial' font-weight='bold'>üìñ</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=NTR&display=swap" rel="stylesheet">
    
    <style>
        :root { --bg-color: #f4f7f6; --text-color: #111111; --cursor-color: #1a73e8; --font-size: 42px; --text-align: center; }
        
        /* Responsive font sizing */
        @media (max-width: 768px) {
            :root { --font-size: 28px; }
        }
        @media (max-width: 480px) {
            :root { --font-size: 22px; }
        }
        body { font-family: 'NTR', sans-serif; background: var(--bg-color); color: var(--text-color); margin: 0; overflow-x: hidden; }
        .settings-container { width: 90%; max-width: 850px; margin: 20px auto; background: white; padding: 25px; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
        body.reading-active .settings-container { display: none; }
        textarea { width: 100%; min-height: 180px; margin-bottom: 20px; padding: 15px; font-size: 18px; border: 2px solid #e0e0e0; border-radius: 10px; }
        .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .option-group { background: #fdfdfd; padding: 12px; border-radius: 10px; border: 1px solid #eee; display: flex; flex-direction: column; gap: 8px; }
        
        /* The container MUST be position: relative for the cursor to align to it */
        .sloka-container { position: relative; width: 100%; max-width: 800px; margin: 0 auto 40px; opacity: 0; transition: opacity 0.5s blur; filter: blur(0px); text-align: var(--text-align, center); }
        .sloka-container.visible { opacity: 1; }
        .sloka-container.fade-out { opacity: 0; filter: blur(8px); }
        
        .line-row { display: block; white-space: normal; word-break: keep-all; overflow-wrap: normal; hyphens: none; margin-bottom: 16px; min-height: 1.2em; position: relative; }
        .char-span { font-size: var(--font-size); display: inline; white-space: pre; line-height: 1.4; position: relative; }
        .word-span { display: inline-block; white-space: nowrap; word-break: keep-all; overflow-wrap: normal; hyphens: none; }
        
        /* Typewriter mode styles - exit transitions only */
        .sloka-container.typewriter-mode { animation: none; text-align: center; }
        .sloka-container.fade-transition { animation: fadeExit 0.6s ease-in-out forwards; }
        .sloka-container.slide-up-transition { animation: slideUpExit 0.6s ease-in-out forwards; }
        .sloka-container.slide-down-transition { animation: slideDownExit 0.6s ease-in-out forwards; }
        .sloka-container.zoom-transition { animation: zoomExit 0.6s ease-in-out forwards; }
        .sloka-container.zoom-in-transition { animation: zoomInExit 0.6s ease-in-out forwards; }
        .sloka-container.rotate-transition { animation: rotateExit 0.6s ease-in-out forwards; }
        .sloka-container.flip-x-transition { animation: flipXExit 0.6s ease-in-out forwards; }
        .sloka-container.flip-y-transition { animation: flipYExit 0.6s ease-in-out forwards; }
        .sloka-container.blur-transition { animation: blurExit 0.6s ease-in-out forwards; }
        .sloka-container.bounce-transition { animation: bounceExit 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards; }
        .sloka-container.wave-transition { animation: waveExit 0.6s ease-in-out forwards; }
        .sloka-container.typewriter-erase-transition { animation: typewriterEraseOut 0.6s ease-in-out forwards; }
        
        @keyframes fadeExit { from { opacity: 1; } to { opacity: 0; } }
        @keyframes slideUpExit { from { opacity: 1; transform: translateY(0); } to { opacity: 0; transform: translateY(-30px); } }
        @keyframes slideDownExit { from { opacity: 1; transform: translateY(0); } to { opacity: 0; transform: translateY(30px); } }
        @keyframes zoomExit { from { opacity: 1; transform: scale(1); } to { opacity: 0; transform: scale(0.9); } }
        @keyframes zoomInExit { from { opacity: 1; transform: scale(1); } to { opacity: 0; transform: scale(1.5); } }
        @keyframes rotateExit { from { opacity: 1; transform: rotate(0deg) scale(1); } to { opacity: 0; transform: rotate(-10deg) scale(0.9); } }
        @keyframes flipXExit { from { opacity: 1; transform: rotateX(0deg); } to { opacity: 0; transform: rotateX(90deg); } }
        @keyframes flipYExit { from { opacity: 1; transform: rotateY(0deg); } to { opacity: 0; transform: rotateY(90deg); } }
        @keyframes blurExit { from { opacity: 1; filter: blur(0px); } to { opacity: 0; filter: blur(10px); } }
        @keyframes bounceExit { 0% { opacity: 1; transform: translateY(0); } 50% { opacity: 1; transform: translateY(5px); } 100% { opacity: 0; transform: translateY(-20px); } }
        @keyframes waveExit { 0% { opacity: 1; transform: skewX(0deg) translateX(0); } 50% { opacity: 1; transform: skewX(5deg) translateX(0); } 100% { opacity: 0; transform: skewX(-10deg) translateX(-30px); } }
        @keyframes typewriterEraseOut { from { clip-path: inset(0 0 0 0); } to { clip-path: inset(0 100% 0 0); } }
        
        /* Entrance animations for Social Media Mode */
        .entrance-fade { animation: fadeIn 0.8s ease-in-out forwards; }
        .entrance-slide-up { animation: slideUpIn 0.8s ease-in-out forwards; }
        .entrance-slide-down { animation: slideDownIn 0.8s ease-in-out forwards; }
        .entrance-slide-left { animation: slideLeftIn 0.8s ease-in-out forwards; }
        .entrance-slide-right { animation: slideRightIn 0.8s ease-in-out forwards; }
        .entrance-zoom { animation: zoomIn 0.8s ease-in-out forwards; }
        .entrance-zoom-out { animation: zoomOutIn 0.8s ease-in-out forwards; }
        .entrance-rotate { animation: rotateIn 0.8s ease-in-out forwards; }
        .entrance-flip-x { animation: flipXIn 0.8s ease-in-out forwards; }
        .entrance-flip-y { animation: flipYIn 0.8s ease-in-out forwards; }
        .entrance-bounce { animation: bounceIn 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards; }
        .entrance-blur { animation: blurIn 0.8s ease-in-out forwards; }
        .entrance-spiral { animation: spiralIn 0.8s ease-in-out forwards; }
        .entrance-typewriter { animation: none; } /* Handled by JS */
        
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideUpIn { from { opacity: 0; transform: translateY(50px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes slideDownIn { from { opacity: 0; transform: translateY(-50px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes slideLeftIn { from { opacity: 0; transform: translateX(50px); } to { opacity: 1; transform: translateX(0); } }
        @keyframes slideRightIn { from { opacity: 0; transform: translateX(-50px); } to { opacity: 1; transform: translateX(0); } }
        @keyframes zoomIn { from { opacity: 0; transform: scale(0.5); } to { opacity: 1; transform: scale(1); } }
        @keyframes zoomOutIn { from { opacity: 0; transform: scale(1.5); } to { opacity: 1; transform: scale(1); } }
        @keyframes rotateIn { from { opacity: 0; transform: rotate(-180deg) scale(0.5); } to { opacity: 1; transform: rotate(0) scale(1); } }
        @keyframes flipXIn { from { opacity: 0; transform: rotateX(90deg); } to { opacity: 1; transform: rotateX(0); } }
        @keyframes flipYIn { from { opacity: 0; transform: rotateY(90deg); } to { opacity: 1; transform: rotateY(0); } }
        @keyframes bounceIn { 0% { opacity: 0; transform: scale(0.3); } 50% { opacity: 1; transform: scale(1.05); } 70% { transform: scale(0.9); } 100% { opacity: 1; transform: scale(1); } }
        @keyframes blurIn { from { opacity: 0; filter: blur(20px); } to { opacity: 1; filter: blur(0px); } }
        @keyframes spiralIn { from { opacity: 0; transform: rotate(720deg) scale(0); } to { opacity: 1; transform: rotate(0) scale(1); } }
        
        /* Rolling entrance effect */
        .entrance-rolling { animation: none; } /* Handled by JS */
        
        #displayArea { display: none; justify-content: center; align-items: center; min-height: 100vh; padding: 10vh 20px; box-sizing: border-box; position: relative; }
        body.portrait-mode #displayArea {
            width: min(100vw, 56.25vh);
            aspect-ratio: 9 / 16;
            height: auto;
            min-height: unset;
            margin: 0 auto;
            padding: 8vh 12px;
        }
        #displayArea::before { content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-size: var(--bg-image-size, cover); background-position: var(--bg-image-position, center); background-image: var(--bg-image); background-repeat: no-repeat; opacity: var(--bg-image-opacity, 1); z-index: -1; pointer-events: none; }
        body.reading-active #displayArea { display: flex; padding-top: calc(10vh + 60px); }
        
        #globalCursor { 
            position: absolute; height: 6px; width: 35px; background: var(--cursor-color);
            border-radius: 3px; z-index: 100;
            pointer-events: none;
        }

        .slider-group { display: flex; align-items: center; gap: 10px; }
        .slider-group input[type="range"] { flex: 1; }
        .slider-group .value-display { min-width: 35px; font-weight: bold; color: var(--text-color); }

        .color-controls { display: flex; gap: 10px; align-items: center; }
        .color-controls input[type="color"] { width: 50px; height: 40px; border: none; border-radius: 6px; cursor: pointer; }
        
        .bg-image-controls { display: flex; flex-direction: column; gap: 10px; }
        .bg-image-controls input[type="file"] { padding: 6px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; }
        .bg-image-row { display: flex; gap: 10px; }
        .recording-controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .recording-controls button { padding: 8px 12px; border: none; border-radius: 8px; cursor: pointer; color: #fff; }
        #recordStartBtn { background: #1a73e8; }
        #recordStopBtn { background: #ea4335; }
        #recordStatus { font-size: 12px; color: #555; }

        #displayArea.scroll-mode { display: flex; flex-direction: column; padding: 40px 20px; overflow-y: hidden; height: 100vh; justify-content: flex-start; align-items: center; }
        #displayArea.scroll-mode .sloka-container { margin-bottom: 40px; opacity: 1 !important; animation: pageBlurIn 0.5s ease-in-out; }

        @keyframes pageBlurIn {
            0% {
                opacity: 0;
                filter: blur(10px);
            }
            100% {
                opacity: 1;
                filter: blur(0px);
            }
        }

        /* Rolling Mode styles */
        #displayArea.rolling-mode { display: flex; flex-direction: column; justify-content: center; align-items: center; overflow: hidden; position: relative; height: 100vh; }
        .rolling-container { position: absolute; top: 0; width: 100%; text-align: center; white-space: pre-wrap; word-wrap: break-word; left: 0; right: 0; will-change: transform; transform-origin: top left; contain: layout style paint; }
        .rolling-line { font-size: var(--font-size); margin: 0.6em 0; line-height: 1.4; color: var(--text-color); padding: 0 20px; white-space: pre-wrap; text-align: var(--text-align, center); word-break: keep-all; overflow-wrap: normal; hyphens: none; }
        .rolling-line.empty { margin: 1.2em 0; }

        #stopBtn { position: fixed; bottom: 30px; right: 30px; background: #ea4335; color: white; border: none; padding: 15px 30px; border-radius: 50px; cursor: pointer; display: none; z-index: 1000; opacity: 0; transition: opacity 0.3s ease; pointer-events: auto; }
        body.reading-active #stopBtn { display: block; }
        body.reading-active.show-reset #stopBtn { opacity: 1; }
        
        /* Kids Learning Mode visual cues */
        .kids-cue { position: fixed; top: 80px; left: 50%; transform: translateX(-50%); font-size: 32px; font-weight: bold; color: #333; opacity: 0; pointer-events: none; z-index: 10000; animation: cueFadeIn 1s ease-out forwards; background: rgba(255, 255, 255, 0.95); padding: 15px 30px; border-radius: 16px; box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4); }
        @keyframes cueFadeIn { 0% { opacity: 0; transform: translateX(-50%) scale(0.5); } 50% { opacity: 1; transform: translateX(-50%) scale(1.1); } 100% { opacity: 1; transform: translateX(-50%) scale(1); } }
        @keyframes cueFadeOut { 0% { opacity: 1; transform: translateX(-50%) scale(1); } 100% { opacity: 0; transform: translateX(-50%) scale(0.8); } }
        .kids-cue.fade-out { animation: cueFadeOut 0.8s ease-in forwards; }
        
        .kids-instruction { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 28px; font-weight: bold; color: #333; z-index: 10000; background: rgba(255, 255, 255, 0.98); padding: 40px 50px; border-radius: 20px; box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5); text-align: center; line-height: 1.6; max-width: 600px; animation: instructionZoom 1s ease-out; }
        @keyframes instructionZoom { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.3); } 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); } }
        .kids-instruction .title { font-size: 36px; color: #1a73e8; margin-bottom: 20px; }
        .kids-instruction .message { font-size: 24px; color: #555; }
        .kids-phase-cue { white-space: nowrap; text-align: center; }
        body.kids-cue-active #displayArea { color: transparent !important; }
        body.kids-cue-active #displayArea .char-span,
        body.kids-cue-active #displayArea .word-span,
        body.kids-cue-active #displayArea .line-row { color: transparent !important; }
        body.kids-cue-active #globalCursor { opacity: 0 !important; }
        body.kids-cue-active #displayArea * { pointer-events: none; }

        .clap { position: fixed; font-size: 48px; z-index: 10001; animation: clapFloat 1.6s ease-out forwards; pointer-events: none; }
        @keyframes clapFloat {
            0% { opacity: 0; transform: translateY(20px) scale(0.6); }
            20% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-60px) scale(1.2); }
        }
        
        /* Watermark branding */
        #branding-watermark { position: fixed; top: 20px; right: 30px; z-index: 999; text-align: center; font-family: 'NTR', sans-serif; line-height: 1.3; pointer-events: none; letter-spacing: 0.5px; }
        #branding-watermark.hidden { display: none; }
        .branding-line { font-size: 16px; font-weight: bold; }
        .branding-line:first-child { font-size: 18px; }
    </style>
</head>
<body>

<div class="settings-container">
    <h2 style="text-align:center;">‡∞¶‡±É‡∞∑‡±ç‡∞ü‡∞ø‡∞™‡∞•‡∞Ç</h2>
    <textarea id="textInput" placeholder="Paste your slokas here..."></textarea>
    <div class="controls">
        <div class="option-group"><span>Mode</span>
            <select id="modeSelect">
                <option value="unifocus">UniFocus Mode</option>
                <option value="typewriter">Typewriter Mode</option>
                <option value="scroll" selected>Continuous Mode</option>
                <option value="rolling">Rolling Mode</option>
                <option value="social">Social Media Mode</option>
                <option value="kids">Kids Learning Mode</option>
            </select>
        </div>
        <div class="option-group" id="transitionOption">
            <span>Sloka Transition</span>
            <select id="transitionSelect">
                <option value="fade">Fade</option>
                <option value="slide-up">Slide Up</option>
                <option value="slide-down">Slide Down</option>
                <option value="zoom">Zoom</option>
                <option value="zoom-in">Zoom In</option>
                <option value="rotate">Rotate</option>
                <option value="flip-x">Flip Horizontal</option>
                <option value="flip-y">Flip Vertical</option>
                <option value="blur">Blur</option>
                <option value="bounce">Bounce</option>
                <option value="wave">Wave</option>
                <option value="typewriter-erase">Typewriter Erase</option>
            </select>
        </div>
        <div class="option-group" id="entranceOption" style="display: none;">
            <span>Entrance Effect</span>
            <select id="entranceSelect">
                <option value="fade">Fade In</option>
                <option value="slide-up">Slide Up</option>
                <option value="slide-down">Slide Down</option>
                <option value="slide-left">Slide Left</option>
                <option value="slide-right">Slide Right</option>
                <option value="zoom">Zoom In</option>
                <option value="zoom-out">Zoom Out</option>
                <option value="rotate">Rotate In</option>
                <option value="flip-x">Flip Horizontal</option>
                <option value="flip-y">Flip Vertical</option>
                <option value="bounce">Bounce In</option>
                <option value="blur">Blur In</option>
                <option value="spiral">Spiral In</option>
                <option value="rolling">Rolling</option>
                <option value="typewriter">Typewriter</option>
            </select>
        </div>
        <div class="option-group" id="exitOption" style="display: none;">
            <span>Exit Effect</span>
            <select id="exitSelect">
                <option value="fade">Fade Out</option>
                <option value="slide-up">Slide Up</option>
                <option value="slide-down">Slide Down</option>
                <option value="zoom">Zoom Out</option>
                <option value="zoom-in">Zoom In</option>
                <option value="rotate">Rotate Out</option>
                <option value="flip-x">Flip Horizontal</option>
                <option value="flip-y">Flip Vertical</option>
                <option value="blur">Blur Out</option>
                <option value="bounce">Bounce Out</option>
                <option value="wave">Wave Out</option>
                <option value="typewriter-erase">Typewriter Erase</option>
            </select>
        </div>
        <div class="option-group">
            <span>Font Size</span>
            <div class="slider-group">
                <input type="range" id="fontSizeControl" min="16" max="80" value="42">
                <span class="value-display" id="fontSizeValue">42</span>
            </div>
        </div>
        <div class="option-group">
            <span>Speed</span>
            <div class="slider-group">
                <input type="range" id="speedControl" min="1" max="12" step="1" value="1">
                <span class="value-display" id="speedValue">1</span>
            </div>
        </div>
        <div class="option-group">
            <span>Text Alignment</span>
            <select id="alignmentSelect">
                <option value="left">Left</option>
                <option value="center" selected>Center</option>
                <option value="right">Right</option>
            </select>
        </div>
        <div class="option-group">
            <span>Recording</span>
            <div class="recording-controls">
                <button id="recordStartBtn" type="button">Start Tab Recording</button>
                <button id="recordStopBtn" type="button" disabled>Stop Recording</button>
                <label style="display: flex; align-items: center; gap: 6px;">
                    <input type="checkbox" id="recordFullscreen">
                    <span>Fullscreen</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px;">
                    <input type="checkbox" id="portraitModeToggle">
                    <span>Portrait 9:16</span>
                </label>
                <span id="recordStatus">Idle</span>
            </div>
        </div>
        <div class="option-group" id="loopOption" style="display: none;">
            <span>Loop Count</span>
            <div class="slider-group">
                <input type="range" id="loopControl" min="1" max="10" step="1" value="1">
                <span class="value-display" id="loopValue">1</span>
            </div>
        </div>
        <div class="option-group" id="textEffectsOption" style="display: none;">
            <span>Text Effects</span>
            <div style="display: flex; flex-direction: column; gap: 8px;">
                <label style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="textShadow" style="cursor: pointer;">
                    <span>Text Shadow</span>
                </label>
                <label style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="textOutline" style="cursor: pointer;">
                    <span>Text Outline</span>
                </label>
                <label style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="textGlow" style="cursor: pointer;">
                    <span>Text Glow</span>
                </label>
            </div>
        </div>
        <div class="option-group" id="fontStyleOption" style="display: none;">
            <span>Font Style (Kids Mode)</span>
            <select id="fontStyleSelect">
                <option value="default">Default</option>
                <option value="bold">Bold & Large</option>
                <option value="rounded">Rounded & Soft</option>
                <option value="colorful">Colorful</option>
                <option value="comic">Comic Sans Style</option>
            </select>
        </div>
        <div class="option-group">
            <span>Colors</span>
            <div class="color-controls">
                <input type="color" id="bgPicker" value="#f4f7f6" title="Background Color">
                <input type="color" id="textPicker" value="#111111" title="Text Color">
                <input type="color" id="cursorPicker" value="#1a73e8" title="Cursor Color">
            </div>
        </div>
        <div class="option-group">
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="showBranding" checked style="cursor: pointer;">
                <span>Show Branding</span>
            </label>
        </div>
        <div class="option-group" id="sampleTextOption" style="display: none;">
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="useSampleText" style="cursor: pointer;">
                <span>Use sample text (local testing)</span>
            </label>
        </div>
        <div class="option-group">
            <span>Background Image</span>
            <div class="bg-image-controls">
                <input type="file" id="bgImageInput" accept="image/*" title="Select background image">
                <div class="bg-image-row">
                    <label style="flex: 1;">Opacity: <span id="bgOpacityValue">30</span>%</label>
                    <input type="range" id="bgOpacity" min="0" max="100" value="30" style="flex: 2;">
                </div>
                <select id="bgPosition" style="padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
                    <option value="center">Align: Center</option>
                    <option value="left">Align: Left</option>
                    <option value="right">Align: Right</option>
                </select>
                <select id="bgSize" style="padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
                    <option value="cover">Cover</option>
                    <option value="contain">Fit</option>
                </select>
            </div>
        </div>
    </div>
    <button onclick="startReading()" style="width:100%; padding:15px; background:#34a853; color:white; border:none; border-radius:8px; cursor:pointer;">Start Reading</button>
</div>

<button id="stopBtn" onclick="stopReading()">Reset</button>
<div id="branding-watermark">
    <div class="branding-line">#AI‡∞∂‡±Ä‡∞®‡±Å</div>
    <div class="branding-line">instagram/norisrinivasa</div>
</div>
<div id="displayArea"></div>

<script>
    let slokas = [], currentSlokaIdx = 0, isReading = false, charTimeout = null, wakeLock = null;
    let resetRevealTimeout = null;
    let readingStartTime = 0;
    let currentLoopCount = 0;
    let maxLoops = 1;
    let mediaRecorder = null;
    let recordedChunks = [];
    let captureStream = null;
    let isRecording = false;
    let kidsCurrentLineIdx = 0;
    let kidsCurrentPhase = 0; // 0: individual words, 1: one line at a time, 2: two lines at a time, 3: full sloka 2x, 4: full sloka real fast 2x
    let kidsAllPoems = [];
    let kidsLoopCount = 0;
    let kidsCurrentPoem = [];
    let kidsCurrentWordIdx = 0;
    const segmenter = new Intl.Segmenter('te', { granularity: 'grapheme' });
    const DRAFT_STORAGE_KEY = 'slokaReader.draft.v1';
    const SAMPLE_TEXT = `‡∞∂‡±Å‡∞ï‡±ç‡∞≤‡∞æ‡∞Ç ‡∞¨‡∞∞‡∞ß‡∞∞‡∞Ç-‡∞µ‡∞ø‡∞Ä‡∞∑‡±ç‡∞£‡±Å‡∞Ç ‡∞∂‡∞∂‡∞ø‡∞µ‡∞∞‡±ç‡∞£‡∞Ç ‡∞ö‡∞§‡±Å‡∞∞‡±ç‡∞≠‡±Å‡∞ú‡∞Æ‡±ç ‡•§
‡∞™‡±ç‡∞∞‡∞∏‡∞®‡±ç‡∞®‡∞µ‡∞¶‡∞®‡∞Ç ‡∞ß‡±ç‡∞Ø‡∞æ‡∞Ø‡±á‡∞§‡±ç ‡∞∏‡∞∞‡±ç‡∞µ ‡∞µ‡∞ø‡∞ò‡±ç‡∞®‡±ã‡∞™‡∞∂‡∞æ‡∞Ç‡∞§‡∞Ø‡±á
‡∞Ø‡∞∏‡±ç‡∞Ø‡∞¶‡±ç‡∞µ‡∞ø‡∞∞‡∞¶ ‡∞µ‡∞ï‡±ç‡∞§‡±ç‡∞∞‡∞æ‡∞¶‡±ç‡∞Ø‡∞æ‡∞É ‡∞™‡∞æ‡∞∞‡∞ø‡∞∑‡∞¶‡±ç‡∞Ø‡∞æ‡∞É ‡∞™‡∞∞‡∞∂‡±ç‡∞∂‡∞§‡∞Æ‡±ç ‡•§
‡∞µ‡∞ø‡∞ò‡±ç‡∞®‡∞Ç ‡∞®‡∞ø‡∞ò‡±ç‡∞®‡∞Ç‡∞§‡±Å ‡∞∏‡∞§‡∞§‡∞Ç-‡∞µ‡∞ø‡∞Ä‡∞∑‡±ç‡∞µ‡∞ï‡±ç‡∞∏‡±á‡∞®‡∞Ç ‡∞§‡∞Æ‡∞æ‡∞∂‡±ç‡∞∞‡∞Ø‡±á ‡••

‡∞∂‡±Å‡∞ï‡±ç‡∞≤‡∞æ‡∞Ç ‡∞¨‡∞∞‡∞ß‡∞∞‡∞Ç-‡∞µ‡∞ø‡∞Ä‡∞∑‡±ç‡∞£‡±Å‡∞Ç ‡∞∂‡∞∂‡∞ø‡∞µ‡∞∞‡±ç‡∞£‡∞Ç ‡∞ö‡∞§‡±Å‡∞∞‡±ç‡∞≠‡±Å‡∞ú‡∞Æ‡±ç ‡•§
‡∞™‡±ç‡∞∞‡∞∏‡∞®‡±ç‡∞®‡∞µ‡∞¶‡∞®‡∞Ç ‡∞ß‡±ç‡∞Ø‡∞æ‡∞Ø‡±á‡∞§‡±ç ‡∞∏‡∞∞‡±ç‡∞µ ‡∞µ‡∞ø‡∞ò‡±ç‡∞®‡±ã‡∞™‡∞∂‡∞æ‡∞Ç‡∞§‡∞Ø‡±á
‡∞Ø‡∞∏‡±ç‡∞Ø‡∞¶‡±ç‡∞µ‡∞ø‡∞∞‡∞¶ ‡∞µ‡∞ï‡±ç‡∞§‡±ç‡∞∞‡∞æ‡∞¶‡±ç‡∞Ø‡∞æ‡∞É ‡∞™‡∞æ‡∞∞‡∞ø‡∞∑‡∞¶‡±ç‡∞Ø‡∞æ‡∞É ‡∞™‡∞∞‡∞∂‡±ç‡∞∂‡∞§‡∞Æ‡±ç ‡•§
‡∞µ‡∞ø‡∞ò‡±ç‡∞®‡∞Ç ‡∞®‡∞ø‡∞ò‡±ç‡∞®‡∞Ç‡∞§‡±Å ‡∞∏‡∞§‡∞§‡∞Ç-‡∞µ‡∞ø‡∞Ä‡∞∑‡±ç‡∞µ‡∞ï‡±ç‡∞∏‡±á‡∞®‡∞Ç ‡∞§‡∞Æ‡∞æ‡∞∂‡±ç‡∞∞‡∞Ø‡±á ‡••

`;
    let hasUnsavedChanges = false;
    let lastDraftText = '';

    // Screen Wake Lock Management for phones
    async function acquireWakeLock() {
        try {
            if ('wakeLock' in navigator && isReading) {
                wakeLock = await navigator.wakeLock.request('screen');
                log.info('Screen wake lock acquired');
            }
        } catch (err) {
            log.warn('Failed to acquire wake lock', err);
        }
    }

    async function releaseWakeLock() {
        try {
            if (wakeLock) {
                await wakeLock.release();
                wakeLock = null;
                log.info('Screen wake lock released');
            }
        } catch (err) {
            log.warn('Failed to release wake lock', err);
        }
    }

    // Logging system
    const log = {
        info: (msg, data = null) => {
            console.log(`[INFO] ${new Date().toISOString().substr(11, 12)} - ${msg}`, data || '');
        },
        debug: (msg, data = null) => {
            console.debug(`[DEBUG] ${new Date().toISOString().substr(11, 12)} - ${msg}`, data || '');
        },
        error: (msg, data = null) => {
            console.error(`[ERROR] ${new Date().toISOString().substr(11, 12)} - ${msg}`, data || '');
        },
        warn: (msg, data = null) => {
            console.warn(`[WARN] ${new Date().toISOString().substr(11, 12)} - ${msg}`, data || '');
        }
    };

    // Calculate luminance of a color to determine contrast
    function getLuminance(hexColor) {
        const rgb = parseInt(hexColor.slice(1), 16);
        const r = (rgb >> 16) & 0xff;
        const g = (rgb >> 8) & 0xff;
        const b = (rgb >> 0) & 0xff;
        return 0.299 * r + 0.587 * g + 0.114 * b;
    }

    log.info('Application initialized');
    log.debug('Segmenter created for Telugu', { granularity: 'grapheme' });

    function saveDraft(text) {
        try {
            if (text !== undefined && text !== null) {
                localStorage.setItem(DRAFT_STORAGE_KEY, text);
                lastDraftText = text;
                console.log('Draft saved:', text.length, 'chars');
            }
        } catch (err) {
            log.warn('Draft save failed', err);
            console.error('Save error:', err);
        }
    }

    function compressImage(imageData, maxWidth = 2048, maxHeight = 2048, quality = 0.8) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                let width = img.width;
                let height = img.height;
                
                // Scale down if too large
                if (width > maxWidth || height > maxHeight) {
                    const scale = Math.min(maxWidth / width, maxHeight / height);
                    width = Math.round(width * scale);
                    height = Math.round(height * scale);
                }
                
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                
                const compressed = canvas.toDataURL('image/jpeg', quality);
                resolve(compressed);
            };
            img.onerror = () => {
                log.warn('Image compression failed, using original');
                resolve(imageData);
            };
            img.src = imageData;
        });
    }

    function saveBackgroundImage(imageData) {
        try {
            localStorage.setItem('slokaReader.bgImage.v1', imageData);
            log.info('Background image saved');
        } catch (err) {
            log.warn('Background image save failed', err);
        }
    }

    function restoreBackgroundImage() {
        try {
            const saved = localStorage.getItem('slokaReader.bgImage.v1');
            if (saved) {
                applyBackgroundImage(saved);
                log.info('Background image restored from local storage');
            }
        } catch (err) {
            log.warn('Background image restore failed', err);
        }
    }

    function applyBackgroundImage(imageData) {
        const displayArea = document.getElementById('displayArea');
        if (!displayArea) return;
        const opacity = (document.getElementById('bgOpacity')?.value || 100) / 100;
        const position = document.getElementById('bgPosition')?.value || 'center';
        const size = document.getElementById('bgSize')?.value || 'cover';
        displayArea.style.setProperty('--bg-image', `url('${imageData}')`);
        displayArea.style.setProperty('--bg-image-opacity', opacity);
        displayArea.style.setProperty('--bg-image-position', position);
        displayArea.style.setProperty('--bg-image-size', size);
    }

    function restoreDraftIfAvailable() {
        try {
            const textInput = document.getElementById('textInput');
            if (!textInput) {
                console.error('textInput element not found!');
                return;
            }

            const saved = localStorage.getItem(DRAFT_STORAGE_KEY);
            console.log('Restoring draft:', saved ? saved.length + ' chars' : 'nothing saved');
            if (saved && saved.trim().length > 0) {
                textInput.value = saved;
                log.info('Draft restored from local storage', { length: saved.length });
            }

            lastDraftText = textInput.value;
            hasUnsavedChanges = false;
        } catch (err) {
            log.warn('Draft restore failed', err);
            console.error('Restore error:', err);
        }
    }

    function applySampleTextIfRequested() {
        if (window.location.protocol !== 'file:') return;
        const sampleToggle = document.getElementById('useSampleText');
        if (!sampleToggle || !textInputEl) return;

        if (sampleToggle.checked && textInputEl.value.trim().length === 0) {
            textInputEl.value = SAMPLE_TEXT;
            saveDraft(textInputEl.value);
            hasUnsavedChanges = false;
        }
    }

    function parseSlokas(text) {
        log.debug('Parsing slokas from text', { textLength: text.length });
        
        // Split by || or double newlines
        let parts = text.split(/\|\||\n\s*\n/);
        const result = parts
            .map(part => part.trim())
            .filter(part => part.length > 0)
            .map(part => part.split('\n'));
            
        log.info('Slokas parsed successfully', { count: result.length, totalLines: result.reduce((sum, sloka) => sum + sloka.length, 0) });
        return result;
    }

    function startReading() {
        const text = document.getElementById('textInput').value.trim();
        console.log('startReading called, text length:', text.length);
        if (!text) {
            log.warn('Start reading called with empty text');
            alert('Please enter some text to read!');
            return;
        }

        log.info('Starting reading session');
        actuallyStartReading(text);
    }
    
    function actuallyStartReading(text) {
        // Update CSS variables from color pickers
        const bgColor = document.getElementById('bgPicker').value;
        const textColor = document.getElementById('textPicker').value;
        const cursorColor = document.getElementById('cursorPicker').value;
        const fontSize = document.getElementById('fontSizeControl').value;
        
        document.documentElement.style.setProperty('--bg-color', bgColor);
        document.documentElement.style.setProperty('--text-color', textColor);
        document.documentElement.style.setProperty('--cursor-color', cursorColor);
        document.documentElement.style.setProperty('--font-size', fontSize + 'px');
        document.body.style.background = bgColor;
        document.body.style.color = textColor;
        
        // Apply text effects
        applyTextEffects();
        
        // Set branding color - contrasting to background
        const brandingEl = document.getElementById('branding-watermark');
        const isLightBg = getLuminance(bgColor) > 128;
        brandingEl.style.color = isLightBg ? '#000000' : '#FFFFFF';
        
        // Show/hide branding based on toggle
        const showBranding = document.getElementById('showBranding').checked;
        if (showBranding) {
            brandingEl.classList.remove('hidden');
        } else {
            brandingEl.classList.add('hidden');
        }
        
        log.debug('UI settings applied', { bgColor, textColor, cursorColor, fontSize });

        const mode = document.getElementById('modeSelect').value;
        log.info('Reading mode selected', { mode });
        
        readingStartTime = Date.now();

        if (mode === 'social') {
            slokas = parseSlokas(text);
            currentSlokaIdx = 0;
            currentLoopCount = 0;
            maxLoops = parseInt(document.getElementById('loopControl').value);
            isReading = true;
            document.body.classList.add('reading-active');
            document.getElementById('displayArea').classList.remove('scroll-mode');
            document.getElementById('displayArea').classList.remove('rolling-mode');
            log.info('Starting Social Media mode with 2-second delay');
            setTimeout(() => renderSocialMediaSloka(), 2000);
        } else if (mode === 'kids') {
            const instructionDiv = document.createElement('div');
            instructionDiv.className = 'kids-instruction';
            instructionDiv.innerHTML = '<div class="title">üìö Sloka Time!</div><div class="message">Listen first, then repeat during the silence.</div>';
            document.body.appendChild(instructionDiv);

            slokas = parseSlokas(text);
            kidsAllPoems = slokas;
            currentSlokaIdx = 0;
            kidsCurrentLineIdx = 0;
            kidsCurrentWordIdx = 0;
            kidsCurrentPhase = 0;
            kidsLoopCount = 0;
            isReading = true;
            document.body.classList.add('reading-active');
            document.getElementById('displayArea').classList.remove('scroll-mode');
            document.getElementById('displayArea').classList.remove('rolling-mode');
            applyKidsFontStyle();
            log.info('Starting Kids Learning mode with instruction overlay');
            setTimeout(() => {
                instructionDiv.remove();
                renderKidsSloka();
            }, 5000);
        } else if (mode === 'unifocus') {
            slokas = parseSlokas(text);
            currentSlokaIdx = 0;
            isReading = true;
            document.body.classList.add('reading-active');
            document.getElementById('displayArea').classList.remove('scroll-mode');
            document.getElementById('displayArea').classList.remove('rolling-mode');
            log.info('Starting UniFocus mode with 2-second delay');
            setTimeout(() => renderSloka(), 2000);
        } else if (mode === 'typewriter') {
            slokas = parseSlokas(text);
            currentSlokaIdx = 0;
            isReading = true;
            document.body.classList.add('reading-active');
            document.getElementById('displayArea').classList.remove('scroll-mode');
            document.getElementById('displayArea').classList.remove('rolling-mode');
            log.info('Starting Typewriter mode with 2-second delay');
            setTimeout(() => renderTypewriterSloka(), 2000);
        } else if (mode === 'scroll') {
            // Continuous scroll mode
            slokas = parseSlokas(text);
            currentSlokaIdx = 0;
            isReading = true;
            document.body.classList.add('reading-active');
            document.getElementById('displayArea').classList.add('scroll-mode');
            document.getElementById('displayArea').classList.remove('rolling-mode');
            log.info('Starting Continuous mode with 2-second delay');
            setTimeout(() => renderScrollMode(), 2000);
        } else if (mode === 'rolling') {
            // Rolling credits mode
            isReading = true;
            document.body.classList.add('reading-active');
            document.getElementById('displayArea').classList.remove('scroll-mode');
            document.getElementById('displayArea').classList.add('rolling-mode');
            log.info('Starting Rolling mode with 2-second delay');
            acquireWakeLock();
            setTimeout(() => renderRollingMode(text), 2000);
        }
    }
    
    function applyTextEffects() {
        const container = document.getElementById('displayArea');
        if (!container) return;
        
        let textShadowValue = 'none';
        let textStrokeValue = 'none';
        let filterValue = 'none';
        
        if (document.getElementById('textShadow')?.checked) {
            textShadowValue = '2px 2px 4px rgba(0,0,0,0.5), -1px -1px 3px rgba(255,255,255,0.3)';
        }
        
        if (document.getElementById('textOutline')?.checked) {
            const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
            const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--bg-color').trim();
            textStrokeValue = `2px ${bgColor}`;
            container.style.setProperty('-webkit-text-stroke', textStrokeValue);
        } else {
            container.style.setProperty('-webkit-text-stroke', 'none');
        }
        
        if (document.getElementById('textGlow')?.checked) {
            const cursorColor = getComputedStyle(document.documentElement).getPropertyValue('--cursor-color').trim();
            filterValue = `drop-shadow(0 0 10px ${cursorColor}) drop-shadow(0 0 20px ${cursorColor})`;
        }
        
        container.style.textShadow = textShadowValue;
        container.style.filter = filterValue;
    }

    function getSupportedMimeType() {
        const types = [
            'video/webm;codecs=vp9',
            'video/webm;codecs=vp8',
            'video/webm'
        ];
        for (const type of types) {
            if (MediaRecorder.isTypeSupported(type)) return type;
        }
        return '';
    }

    async function startTabRecording() {
        if (isRecording) return;
        if (!navigator.mediaDevices?.getDisplayMedia) {
            log.warn('Tab recording not supported in this browser');
            updateRecordingStatus('Not supported');
            return;
        }

        try {
            const fullscreenRequested = document.getElementById('recordFullscreen')?.checked;
            if (fullscreenRequested && !document.fullscreenElement) {
                await document.documentElement.requestFullscreen();
            }

            const stream = await navigator.mediaDevices.getDisplayMedia({
                video: {
                    displaySurface: 'browser',
                    preferCurrentTab: true
                },
                audio: false
            });

            captureStream = stream;
            recordedChunks = [];

            const mimeType = getSupportedMimeType();
            mediaRecorder = mimeType ? new MediaRecorder(stream, { mimeType }) : new MediaRecorder(stream);

            mediaRecorder.ondataavailable = (event) => {
                if (event.data && event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: mimeType || 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `sloka-recording-${Date.now()}.webm`;
                a.click();
                URL.revokeObjectURL(url);
                recordedChunks = [];
            };

            stream.getVideoTracks()[0].addEventListener('ended', () => {
                stopTabRecording();
            });

            // Request periodic data to avoid empty recordings in some browsers
            mediaRecorder.start(1000);
            isRecording = true;
            updateRecordingStatus('Recording...');
            toggleRecordingButtons(true);
            log.info('Tab recording started');
        } catch (err) {
            log.error('Failed to start tab recording', err);
            updateRecordingStatus('Failed to start');
            toggleRecordingButtons(false);
        }
    }

    function stopTabRecording() {
        if (!isRecording) return;

        try {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            captureStream?.getTracks().forEach((track) => track.stop());
            captureStream = null;
            isRecording = false;
            updateRecordingStatus('Saved');
            toggleRecordingButtons(false);
            if (document.fullscreenElement) {
                document.exitFullscreen().catch(() => {});
            }
            log.info('Tab recording stopped');
        } catch (err) {
            log.error('Failed to stop tab recording', err);
        }
    }

    function updateRecordingStatus(statusText) {
        const statusEl = document.getElementById('recordStatus');
        if (statusEl) statusEl.textContent = statusText;
    }

    function toggleRecordingButtons(isActive) {
        const startBtn = document.getElementById('recordStartBtn');
        const stopBtn = document.getElementById('recordStopBtn');
        if (startBtn) startBtn.disabled = isActive;
        if (stopBtn) stopBtn.disabled = !isActive;
    }
    
    function applyKidsFontStyle() {
        const fontStyle = document.getElementById('fontStyleSelect')?.value || 'default';
        const container = document.getElementById('displayArea');
        if (!container) return;
        
        // Reset all styles first
        container.style.fontWeight = 'normal';
        container.style.letterSpacing = 'normal';
        container.style.fontFamily = "'NTR', sans-serif";
        container.style.textShadow = 'none';
        
        switch(fontStyle) {
            case 'bold':
                container.style.fontWeight = 'bold';
                container.style.fontSize = 'calc(var(--font-size) * 1.2)';
                break;
            case 'rounded':
                container.style.fontFamily = "'Trebuchet MS', 'Comic Sans MS', sans-serif";
                container.style.letterSpacing = '0.5px';
                break;
            case 'colorful':
                container.style.textShadow = '2px 2px 4px rgba(0,0,0,0.3)';
                break;
            case 'comic':
                container.style.fontFamily = "'Comic Sans MS', cursive";
                container.style.fontWeight = 'bold';
                container.style.fontSize = 'calc(var(--font-size) * 1.15)';
                break;
        }
    }
    
    function showKidsCue(text) {
        // Remove any existing cue
        const existing = document.getElementById('kidsCue');
        if (existing) existing.remove();
        
        const cue = document.createElement('div');
        cue.id = 'kidsCue';
        cue.className = 'kids-cue';
        cue.textContent = text;
        document.body.appendChild(cue);
        
        // Keep visible longer, remove after 3.5 seconds
        setTimeout(() => {
            cue.classList.add('fade-out');
            setTimeout(() => cue.remove(), 800);
        }, 3500);
    }

    function showPhaseCue(message, onDone, duration = 2500) {
        const existing = document.getElementById('kidsPhaseCue');
        if (existing) existing.remove();

        document.body.classList.add('kids-cue-active');

        const cue = document.createElement('div');
        cue.id = 'kidsPhaseCue';
        cue.className = 'kids-instruction kids-phase-cue';
        cue.innerHTML = `<div class="title">${message}</div>`;
        document.body.appendChild(cue);

        setTimeout(() => {
            cue.remove();
            document.body.classList.remove('kids-cue-active');
            if (onDone) onDone();
        }, duration);
    }

    function showClapsCelebration(onDone, duration = 10000) {
        document.body.classList.add('kids-cue-active');

        const awesome = document.createElement('div');
        awesome.className = 'kids-instruction';
        awesome.innerHTML = '<div class="title">Awesome... üëè</div><div class="message">Practice daily</div><div class="message">üôè Harih Om üôè</div>';
        document.body.appendChild(awesome);

        const claps = [];
        const spawnClap = () => {
            const clap = document.createElement('div');
            clap.className = 'clap';
            clap.textContent = 'üëè';
            clap.style.left = Math.floor(10 + Math.random() * 80) + 'vw';
            clap.style.top = Math.floor(40 + Math.random() * 30) + 'vh';
            clap.style.animationDelay = (Math.random() * 0.4) + 's';
            document.body.appendChild(clap);
            claps.push(clap);
        };

        let cancelled = false;
        const cleanup = () => {
            if (cancelled) return;
            cancelled = true;
            clearInterval(clapInterval);
            clearTimeout(stopClapsTimeout);
            clearTimeout(doneTimeout);
            awesome.remove();
            claps.forEach((c) => c.remove());
            document.body.classList.remove('kids-cue-active');
        };

        const clapInterval = setInterval(spawnClap, 220);
        const stopClapsTimeout = setTimeout(() => clearInterval(clapInterval), Math.max(600, duration - 600));

        const doneTimeout = setTimeout(() => {
            cleanup();
            if (onDone) onDone();
        }, duration);

        const stopBtn = document.getElementById('stopBtn');
        if (stopBtn) {
            const onStop = () => {
                cleanup();
                stopBtn.removeEventListener('click', onStop);
            };
            stopBtn.addEventListener('click', onStop);
        }
    }

    function getKidsSpeedMultiplier() {
        const speedValue = parseFloat(document.getElementById('speedControl')?.value || '1');
        return Number.isFinite(speedValue) && speedValue > 0 ? speedValue : 1;
    }
    
    function animateKidsTwoLineGroups(sequence, container, speedMultiplier) {
        // Group lines into pairs (lines 0-1, then 2-3) and animate each group twice
        if (!isReading || sequence.length === 0) {
            setTimeout(() => renderKidsSloka(), 1000);
            return;
        }
        
        acquireWakeLock();
        
        // Find line boundaries
        const charPositions = [];
        const lineIndices = [];
        let currentLineStart = 0;
        let lastTop = null;
        
        for (let i = 0; i < sequence.length; i++) {
            const charEl = document.getElementById(sequence[i].id);
            if (charEl) {
                const charRect = charEl.getBoundingClientRect();
                const charTop = charRect.bottom - 10;
                charPositions.push({ left: charRect.left, top: charTop });
                
                if (lastTop !== null && Math.abs(charTop - lastTop) > 5) {
                    lineIndices.push({ start: currentLineStart, end: i - 1 });
                    currentLineStart = i;
                }
                lastTop = charTop;
            }
        }
        lineIndices.push({ start: currentLineStart, end: sequence.length - 1 });
        
        // Group lines into pairs
        const lineGroups = [];
        for (let i = 0; i < lineIndices.length; i += 2) {
            if (i + 1 < lineIndices.length) {
                lineGroups.push([lineIndices[i], lineIndices[i + 1]]);
            } else {
                lineGroups.push([lineIndices[i]]);
            }
        }
        
        let groupIdx = 0;
        const pixelsPerSecond = 50 * speedMultiplier;
        
        const animateNextGroup = () => {
            if (groupIdx >= lineGroups.length) {
                releaseWakeLock();
                setTimeout(() => renderKidsSloka(), 500);
                return;
            }
            
            const group = lineGroups[groupIdx];
            const groupStart = group[0].start;
            const groupEnd = group[group.length - 1].end;
            const groupPositions = charPositions.slice(groupStart, groupEnd + 1);
            
            // Calculate distance for this group
            let groupDistance = 0;
            for (let i = 0; i < groupPositions.length - 1; i++) {
                const curr = groupPositions[i];
                const next = groupPositions[i + 1];
                groupDistance += Math.max(0, next.left - curr.left);
            }
            
            const groupDuration = groupDistance > 0 ? (groupDistance / pixelsPerSecond) * 1000 : 300;
            let passCount = 0;
            
            const animateGroupPass = () => {
                passCount++;
                
                const animationStartTime = performance.now();
                const updateCursor = (currentTime) => {
                    if (!isReading) return;
                    
                    const elapsed = currentTime - animationStartTime;
                    const progress = Math.min(elapsed / groupDuration, 1);
                    const targetDistance = progress * groupDistance;
                    
                    let accumulatedDist = 0;
                    let cursorPos = null;
                    
                    for (let i = 0; i < groupPositions.length - 1; i++) {
                        const curr = groupPositions[i];
                        const next = groupPositions[i + 1];
                        const segmentDist = Math.max(0, next.left - curr.left);
                        
                        if (accumulatedDist + segmentDist >= targetDistance) {
                            const segmentProgress = segmentDist > 0 ? (targetDistance - accumulatedDist) / segmentDist : 0;
                            const interpolatedLeft = curr.left + (next.left - curr.left) * Math.min(segmentProgress, 1);
                            cursorPos = { left: interpolatedLeft, top: curr.top };
                            break;
                        }
                        accumulatedDist += segmentDist;
                    }
                    
                    if (!cursorPos) {
                        cursorPos = { left: groupPositions[groupPositions.length - 1].left, top: groupPositions[groupPositions.length - 1].top };
                    }
                    
                    let cursor = document.getElementById('globalCursor');
                    if (!cursor) {
                        cursor = document.createElement('div');
                        cursor.id = 'globalCursor';
                        cursor.style.position = 'fixed';
                        cursor.style.height = '6px';
                        cursor.style.width = '35px';
                        cursor.style.borderRadius = '3px';
                        cursor.style.zIndex = '100';
                        cursor.style.pointerEvents = 'none';
                        document.body.appendChild(cursor);
                    }
                    
                    cursor.style.left = cursorPos.left + 'px';
                    cursor.style.top = cursorPos.top + 'px';
                    cursor.style.background = getComputedStyle(document.documentElement).getPropertyValue('--cursor-color').trim();
                    
                    if (progress < 1) {
                        requestAnimationFrame(updateCursor);
                    } else {
                        if (passCount < 2) {
                            setTimeout(animateGroupPass, 1000);
                        } else {
                            groupIdx++;
                            setTimeout(animateNextGroup, 1000);
                        }
                    }
                };
                
                requestAnimationFrame(updateCursor);
            };
            
            animateGroupPass();
        };
        
        animateNextGroup();
    }
    
    function renderKidsSloka() {
        if (!isReading || currentSlokaIdx >= slokas.length) {
            log.info('Kids learning mode complete');
            return stopReading();
        }

        const sloka = slokas[currentSlokaIdx];
        const numLines = sloka.length;

        if (kidsCurrentPhase === 0) {
            // Phase 0: Show full line with words appearing one after another
            if (kidsCurrentLineIdx < numLines) {
                if (kidsCurrentLineIdx === 0) {
                    showPhaseCue('Slow chant', () => {
                        renderKidsLineProgressive(sloka[kidsCurrentLineIdx]);
                        kidsCurrentLineIdx++;
                    });
                    return;
                }
                renderKidsLineProgressive(sloka[kidsCurrentLineIdx]);
                kidsCurrentLineIdx++;
            } else {
                // Move to phase 1
                kidsCurrentPhase = 1;
                kidsCurrentLineIdx = 0;
                showPhaseCue('One line at a time', () => {
                    renderKidsFullPoem(sloka, 1, 1); // Full poem, each line repeated 2x
                });
            }
        } else if (kidsCurrentPhase === 1) {
            // Phase 1: Full poem with each line repeated 2x at 2x speed
            kidsCurrentPhase = 2;
            showPhaseCue('Two lines at a time', () => {
                renderKidsFullPoem(sloka, 1, 2); // Full poem, 2 lines at a time repeated
            });
        } else if (kidsCurrentPhase === 2) {
            // Phase 2: Full poem with 2-line groups repeated at 2x speed
            kidsCurrentPhase = 3;
            showPhaseCue('Now... Full Sloka üôÇ', () => {
                renderKidsFullPoem(sloka, 1, 3); // Full poem repeated 2x
            });
        } else if (kidsCurrentPhase === 3) {
            // Phase 3: Full poem repeated 2x - then move to phase 4
            kidsCurrentPhase = 4;
            showPhaseCue('Now... Full Sloka real fast üòÑ', () => {
                renderKidsFullPoem(sloka, 2, 4); // Full poem repeated 2x at base speed + 1
            });
        } else if (kidsCurrentPhase === 4) {
            // Phase 4: Full poem repeated 2x at base speed + 1 - then done
            showPhaseCue('Now.. Full Sloka real fast üòä', () => {
                renderKidsFullPoem(sloka, 2, 4);
            });
        }
    }
    
    function renderKidsLine(line, withRepetition = true) {
        const area = document.getElementById('displayArea');
        area.innerHTML = '';
        
        const container = document.createElement('div');
        container.className = 'sloka-container';
        container.style.textAlign = 'center';
        
        const row = document.createElement('div');
        row.className = 'line-row';
        
        const segments = Array.from(segmenter.segment(line));
        const charSequence = [];
        
        // Group characters into words
        let currentWord = [];
        segments.forEach((seg, sIdx) => {
            if (seg.segment === ' ') {
                if (currentWord.length > 0) {
                    const wordSpan = document.createElement('span');
                    wordSpan.className = 'word-span';
                    currentWord.forEach(({ segment, id }) => {
                        const span = document.createElement('span');
                        span.className = 'char-span';
                        span.id = id;
                        span.textContent = segment;
                        wordSpan.appendChild(span);
                        charSequence.push({ id: span.id, lineIdx: 0 });
                    });
                    row.appendChild(wordSpan);
                    currentWord = [];
                }
                const spaceSpan = document.createElement('span');
                spaceSpan.className = 'char-span';
                spaceSpan.id = `kids-c-space-${sIdx}`;
                spaceSpan.textContent = ' ';
                row.appendChild(spaceSpan);
                charSequence.push({ id: spaceSpan.id, lineIdx: 0 });
            } else {
                currentWord.push({ segment: seg.segment, id: `kids-c-${sIdx}` });
            }
        });
        
        if (currentWord.length > 0) {
            const wordSpan = document.createElement('span');
            wordSpan.className = 'word-span';
            currentWord.forEach(({ segment, id }) => {
                const span = document.createElement('span');
                span.className = 'char-span';
                span.id = id;
                span.textContent = segment;
                wordSpan.appendChild(span);
                charSequence.push({ id: span.id, lineIdx: 0 });
            });
            row.appendChild(wordSpan);
        }
        
        container.appendChild(row);
        area.appendChild(container);
        
        setTimeout(() => {
            container.classList.add('visible');
            applyKidsFontStyle();
            // Animate cursor twice
            let passCount = 0;
            const animatePass = () => {
                passCount++;
                const speed = getKidsSpeedMultiplier();
                animateKidsLineOnce(charSequence, container, speed, () => {
                    if (passCount < 2) {
                        setTimeout(animatePass, 1000);
                    } else {
                        setTimeout(() => {
                            renderKidsSloka();
                        }, 500);
                    }
                });
            };
            animatePass();
        }, 100);
    }
    
    function renderKidsLineProgressive(line) {
        const area = document.getElementById('displayArea');
        area.innerHTML = '';
        
        const container = document.createElement('div');
        container.className = 'sloka-container';
        container.style.textAlign = 'center';
        
        const row = document.createElement('div');
        row.className = 'line-row';
        
        const segments = Array.from(segmenter.segment(line));
        const words = [];
        let currentWord = [];
        
        // Group characters into words
        segments.forEach((seg, sIdx) => {
            if (seg.segment === ' ') {
                if (currentWord.length > 0) {
                    const wordSpan = document.createElement('span');
                    wordSpan.className = 'word-span';
                    wordSpan.style.opacity = '0';
                    currentWord.forEach(({ segment, id }) => {
                        const span = document.createElement('span');
                        span.className = 'char-span';
                        span.id = id;
                        span.textContent = segment;
                        wordSpan.appendChild(span);
                    });
                    row.appendChild(wordSpan);
                    words.push(wordSpan);
                    currentWord = [];
                }
                const spaceSpan = document.createElement('span');
                spaceSpan.className = 'char-span';
                spaceSpan.id = `kids-c-space-${sIdx}`;
                spaceSpan.textContent = ' ';
                row.appendChild(spaceSpan);
            } else {
                currentWord.push({ segment: seg.segment, id: `kids-c-${sIdx}` });
            }
        });
        
        if (currentWord.length > 0) {
            const wordSpan = document.createElement('span');
            wordSpan.className = 'word-span';
            wordSpan.style.opacity = '0';
            currentWord.forEach(({ segment, id }) => {
                const span = document.createElement('span');
                span.className = 'char-span';
                span.id = id;
                span.textContent = segment;
                wordSpan.appendChild(span);
            });
            row.appendChild(wordSpan);
            words.push(wordSpan);
        }
        
        container.appendChild(row);
        area.appendChild(container);
        
        setTimeout(() => {
            container.classList.add('visible');
            applyKidsFontStyle();
            
            // Reveal words one by one with repetition time
            const speed = getKidsSpeedMultiplier();
            const wordDelay = Math.max(1500, 2500 / speed); // Time word stays visible
            const repetitionGap = Math.max(1000, 1500 / speed); // Gap for repetition
            
            let wordIdx = 0;
            const revealNextWord = () => {
                if (wordIdx >= words.length) {
                    // All words shown, wait before next line
                    setTimeout(() => {
                        renderKidsSloka();
                    }, 1000);
                    return;
                }
                
                const word = words[wordIdx];
                // Show word
                word.style.transition = 'opacity 0.3s';
                word.style.opacity = '1';
                
                // Wait, then move to next word
                setTimeout(() => {
                    wordIdx++;
                    revealNextWord();
                }, wordDelay + repetitionGap);
            };
            
            revealNextWord();
        }, 100);
    }
    
    function renderKidsFullPoem(sloka, speedMultiplier, phase) {
        const area = document.getElementById('displayArea');
        area.innerHTML = '';
        
        const container = document.createElement('div');
        container.className = 'sloka-container';
        
        const charSequence = [];
        
        sloka.forEach((line, lIdx) => {
            const row = document.createElement('div');
            row.className = 'line-row';
            
            if (line.trim() === "") {
                row.style.height = "1.5em";
                container.appendChild(row);
            } else {
                const segments = Array.from(segmenter.segment(line));
                
                // Group characters into words
                let currentWord = [];
                segments.forEach((seg, sIdx) => {
                    if (seg.segment === ' ') {
                        if (currentWord.length > 0) {
                            const wordSpan = document.createElement('span');
                            wordSpan.className = 'word-span';
                            currentWord.forEach(({ segment, id }) => {
                                const span = document.createElement('span');
                                span.className = 'char-span';
                                span.id = id;
                                span.textContent = segment;
                                wordSpan.appendChild(span);
                                charSequence.push({ id: span.id, lineIdx: lIdx });
                            });
                            row.appendChild(wordSpan);
                            currentWord = [];
                        }
                        const spaceSpan = document.createElement('span');
                        spaceSpan.className = 'char-span';
                        spaceSpan.id = `kids-c-${lIdx}-space-${sIdx}`;
                        spaceSpan.textContent = ' ';
                        row.appendChild(spaceSpan);
                        charSequence.push({ id: spaceSpan.id, lineIdx: lIdx });
                    } else {
                        currentWord.push({ segment: seg.segment, id: `kids-c-${lIdx}-${sIdx}` });
                    }
                });
                
                if (currentWord.length > 0) {
                    const wordSpan = document.createElement('span');
                    wordSpan.className = 'word-span';
                    currentWord.forEach(({ segment, id }) => {
                        const span = document.createElement('span');
                        span.className = 'char-span';
                        span.id = id;
                        span.textContent = segment;
                        wordSpan.appendChild(span);
                        charSequence.push({ id: span.id, lineIdx: lIdx });
                    });
                    row.appendChild(wordSpan);
                }
                container.appendChild(row);
            }
        });

        area.appendChild(container);
        
        setTimeout(() => {
            container.classList.add('visible');
            applyKidsFontStyle();
            const speed = getKidsSpeedMultiplier();
            // Phase 4 uses (base + 1) * speed for faster animation
            const adjustedSpeed = phase === 4 ? speed + 1 : speed;
            
            if (phase === 1) {
                // Phase 1: Each line repeated 2x
                animateKidsCursor(charSequence, container, adjustedSpeed, true);
            } else if (phase === 2) {
                // Phase 2: Two-line groups with repetition at 2x speed
                animateKidsTwoLineGroups(charSequence, container, adjustedSpeed);
            } else if (phase === 3 || phase === 4) {
                // Phase 3 & 4: Full poem 2x repetition (phase 4 is faster)
                animateKidsFullPoem(charSequence, container, adjustedSpeed, phase);
            }
        }, 100);
    }
    
    function animateKidsLineOnce(sequence, container, speedMultiplier, callback) {
        if (!isReading || sequence.length === 0) {
            if (callback) callback();
            return;
        }
        
        acquireWakeLock();

        // Create or reuse fixed positioned cursor
        let cursor = document.getElementById('globalCursor');
        if (!cursor) {
            cursor = document.createElement('div');
            cursor.id = 'globalCursor';
            cursor.style.position = 'fixed';
            cursor.style.height = '6px';
            cursor.style.width = '35px';
            cursor.style.borderRadius = '3px';
            cursor.style.zIndex = '100';
            cursor.style.pointerEvents = 'none';
            document.body.appendChild(cursor);
        }

        // Pre-calculate all character positions
        const charPositions = [];
        
        for (let i = 0; i < sequence.length; i++) {
            const charEl = document.getElementById(sequence[i].id);
            if (charEl) {
                const charRect = charEl.getBoundingClientRect();
                charPositions.push({
                    left: charRect.left,
                    top: charRect.bottom - 10
                });
            }
        }

        if (charPositions.length === 0) {
            if (callback) callback();
            return;
        }

        // Calculate total horizontal distance (sum of all left-to-right movements on each line)
        let totalDistance = 0;
        for (let i = 0; i < charPositions.length - 1; i++) {
            const curr = charPositions[i];
            const next = charPositions[i + 1];
            // Only count horizontal distance if on same line
            if (Math.abs(next.top - curr.top) < 5) {
                totalDistance += Math.max(0, next.left - curr.left);
            } else {
                // Line break - jump to next line's first character
                totalDistance += Math.max(0, next.left - charPositions[0].left);
            }
        }

        const pixelsPerSecond = 50 * speedMultiplier;
        const totalDuration = totalDistance > 0 ? (totalDistance / pixelsPerSecond) * 1000 : 500;
        const animationStartTime = performance.now();

        const updateCursorPosition = (currentTime) => {
            if (!isReading) return;

            const elapsed = currentTime - animationStartTime;
            const progress = Math.min(elapsed / totalDuration, 1);
            const targetDistance = progress * totalDistance;

            // Find cursor position based on distance traveled
            let accumulatedDist = 0;
            let cursorPos = null;
            
            for (let i = 0; i < charPositions.length - 1; i++) {
                const curr = charPositions[i];
                const next = charPositions[i + 1];
                let segmentDist = 0;
                
                if (Math.abs(next.top - curr.top) < 5) {
                    // Same line - horizontal distance
                    segmentDist = Math.max(0, next.left - curr.left);
                } else {
                    // Line break - distance to start of next line
                    segmentDist = Math.max(0, next.left - charPositions[0].left);
                }
                
                if (accumulatedDist + segmentDist >= targetDistance) {
                    // Found the segment
                    const segmentProgress = segmentDist > 0 ? (targetDistance - accumulatedDist) / segmentDist : 0;
                    const interpolatedLeft = curr.left + (next.left - curr.left) * Math.min(segmentProgress, 1);
                    cursorPos = { left: interpolatedLeft, top: curr.top };
                    break;
                }
                accumulatedDist += segmentDist;
            }
            
            // Fallback to last position
            if (!cursorPos) {
                cursorPos = { left: charPositions[charPositions.length - 1].left, top: charPositions[charPositions.length - 1].top };
            }

            const cursor = document.getElementById('globalCursor');
            if (cursor) {
                cursor.style.left = cursorPos.left + 'px';
                cursor.style.top = cursorPos.top + 'px';
                cursor.style.background = getComputedStyle(document.documentElement).getPropertyValue('--cursor-color').trim();
            }

            if (progress < 1) {
                requestAnimationFrame(updateCursorPosition);
            } else {
                releaseWakeLock();
                if (callback) callback();
            }
        };

        requestAnimationFrame(updateCursorPosition);
    }
    
    function animateKidsCursor(sequence, container, speedMultiplier, repeatPerLine = false) {
        if (!isReading || sequence.length === 0) {
            setTimeout(() => {
                renderKidsSloka();
            }, 1000);
            return;
        }
        
        acquireWakeLock();

        // Pre-calculate all character positions and find line boundaries
        const charPositions = [];
        const lineIndices = []; // Track start and end indices of each line
        let currentLineStart = 0;
        let lastTop = null;
        
        for (let i = 0; i < sequence.length; i++) {
            const charEl = document.getElementById(sequence[i].id);
            if (charEl) {
                const charRect = charEl.getBoundingClientRect();
                const charTop = charRect.bottom - 10;
                charPositions.push({
                    left: charRect.left,
                    top: charTop
                });
                
                // Detect line change
                if (lastTop !== null && Math.abs(charTop - lastTop) > 5) {
                    lineIndices.push({ start: currentLineStart, end: i - 1 });
                    currentLineStart = i;
                }
                lastTop = charTop;
            }
        }
        lineIndices.push({ start: currentLineStart, end: sequence.length - 1 });

        if (charPositions.length === 0) {
            setTimeout(() => {
                renderKidsSloka();
            }, 1000);
            return;
        }

        // Create or reuse cursor
        let cursor = document.getElementById('globalCursor');
        if (!cursor) {
            cursor = document.createElement('div');
            cursor.id = 'globalCursor';
            cursor.style.position = 'fixed';
            cursor.style.height = '6px';
            cursor.style.width = '35px';
            cursor.style.borderRadius = '3px';
            cursor.style.zIndex = '100';
            cursor.style.pointerEvents = 'none';
            document.body.appendChild(cursor);
        }

        const pixelsPerSecond = 50 * speedMultiplier;
        
        // Animate line by line
        let lineIdx = 0;
        
        const animateNextLine = () => {
            if (lineIdx >= lineIndices.length) {
                // All lines done
                releaseWakeLock();
                setTimeout(() => {
                    renderKidsSloka();
                }, 500);
                return;
            }
            
            const lineBounds = lineIndices[lineIdx];
            const lineCharPositions = charPositions.slice(lineBounds.start, lineBounds.end + 1);
            
            // Calculate distance for this line only
            let lineDistance = 0;
            for (let i = 0; i < lineCharPositions.length - 1; i++) {
                const curr = lineCharPositions[i];
                const next = lineCharPositions[i + 1];
                lineDistance += Math.max(0, next.left - curr.left);
            }
            
            const lineDuration = lineDistance > 0 ? (lineDistance / pixelsPerSecond) * 1000 : 300;
            
            // Animate this line (potentially with repetition)
            let linePass = 0;
            const animateLinePass = () => {
                linePass++;
                const animationStartTime = performance.now();

                const updateCursorPosition = (currentTime) => {
                    if (!isReading) return;

                    const elapsed = currentTime - animationStartTime;
                    const progress = Math.min(elapsed / lineDuration, 1);
                    const targetDistance = progress * lineDistance;

                    // Find cursor position in this line
                    let accumulatedDist = 0;
                    let cursorPos = null;
                    
                    for (let i = 0; i < lineCharPositions.length - 1; i++) {
                        const curr = lineCharPositions[i];
                        const next = lineCharPositions[i + 1];
                        const segmentDist = Math.max(0, next.left - curr.left);
                        
                        if (accumulatedDist + segmentDist >= targetDistance) {
                            const segmentProgress = segmentDist > 0 ? (targetDistance - accumulatedDist) / segmentDist : 0;
                            const interpolatedLeft = curr.left + (next.left - curr.left) * Math.min(segmentProgress, 1);
                            cursorPos = { left: interpolatedLeft, top: curr.top };
                            break;
                        }
                        accumulatedDist += segmentDist;
                    }
                    
                    if (!cursorPos) {
                        cursorPos = { left: lineCharPositions[lineCharPositions.length - 1].left, top: lineCharPositions[lineCharPositions.length - 1].top };
                    }

                    const cursor = document.getElementById('globalCursor');
                    if (cursor) {
                        cursor.style.left = cursorPos.left + 'px';
                        cursor.style.top = cursorPos.top + 'px';
                        cursor.style.background = getComputedStyle(document.documentElement).getPropertyValue('--cursor-color').trim();
                    }

                    if (progress < 1) {
                        requestAnimationFrame(updateCursorPosition);
                    } else {
                        // Line animation complete
                        if (repeatPerLine && linePass < 2) {
                            // Repeat this line
                            setTimeout(animateLinePass, 300);
                        } else {
                            // Move to next line
                            lineIdx++;
                            setTimeout(animateNextLine, 300);
                        }
                    }
                };

                requestAnimationFrame(updateCursorPosition);
            };
            
            animateLinePass();
        };
        
        animateNextLine();
    }
    
    function animateKidsFullPoem(sequence, container, speedMultiplier, phase) {
        // Line-by-line full poem, repeated twice
        if (!isReading || sequence.length === 0) {
            setTimeout(() => {
                renderKidsSloka();
            }, 1000);
            return;
        }

        acquireWakeLock();

        const charPositions = [];
        const lineIndices = [];
        let currentLineStart = 0;
        let lastTop = null;

        for (let i = 0; i < sequence.length; i++) {
            const charEl = document.getElementById(sequence[i].id);
            if (charEl) {
                const charRect = charEl.getBoundingClientRect();
                const charTop = charRect.bottom - 10;
                charPositions.push({ left: charRect.left, top: charTop });

                if (lastTop !== null && Math.abs(charTop - lastTop) > 5) {
                    lineIndices.push({ start: currentLineStart, end: i - 1 });
                    currentLineStart = i;
                }
                lastTop = charTop;
            }
        }
        lineIndices.push({ start: currentLineStart, end: sequence.length - 1 });

        if (charPositions.length === 0) {
            setTimeout(() => {
                renderKidsSloka();
            }, 1000);
            return;
        }

        let cursor = document.getElementById('globalCursor');
        if (!cursor) {
            cursor = document.createElement('div');
            cursor.id = 'globalCursor';
            cursor.style.position = 'fixed';
            cursor.style.height = '6px';
            cursor.style.width = '35px';
            cursor.style.borderRadius = '3px';
            cursor.style.zIndex = '100';
            cursor.style.pointerEvents = 'none';
            document.body.appendChild(cursor);
        }

        const pixelsPerSecond = 50 * speedMultiplier;
        let poemPass = 0;

        const animatePoemPass = () => {
            poemPass++;
            let lineIdx = 0;

            const animateNextLine = () => {
                if (lineIdx >= lineIndices.length) {
                    if (poemPass < 2) {
                        const pauseTime = 1000;
                        setTimeout(animatePoemPass, pauseTime);
                        return;
                    }

                    releaseWakeLock();
                    const advance = () => {
                        kidsCurrentPhase++;
                        if (kidsCurrentPhase > 4) {
                            kidsCurrentPhase = 0;
                            kidsCurrentLineIdx = 0;
                            currentSlokaIdx++;
                        }
                        renderKidsSloka();
                    };

                    if (kidsCurrentPhase === 4) {
                        showClapsCelebration(advance, 10000);
                    } else {
                        setTimeout(advance, 500);
                    }
                    return;
                }

                const lineBounds = lineIndices[lineIdx];
                const lineCharPositions = charPositions.slice(lineBounds.start, lineBounds.end + 1);

                let lineDistance = 0;
                for (let i = 0; i < lineCharPositions.length - 1; i++) {
                    const curr = lineCharPositions[i];
                    const next = lineCharPositions[i + 1];
                    lineDistance += Math.max(0, next.left - curr.left);
                }

                const lineDuration = lineDistance > 0 ? (lineDistance / pixelsPerSecond) * 1000 : 300;
                const animationStartTime = performance.now();

                const updateCursorPosition = (currentTime) => {
                    if (!isReading) return;

                    const elapsed = currentTime - animationStartTime;
                    const progress = Math.min(elapsed / lineDuration, 1);
                    const targetDistance = progress * lineDistance;

                    let accumulatedDist = 0;
                    let cursorPos = null;

                    for (let i = 0; i < lineCharPositions.length - 1; i++) {
                        const curr = lineCharPositions[i];
                        const next = lineCharPositions[i + 1];
                        const segmentDist = Math.max(0, next.left - curr.left);

                        if (accumulatedDist + segmentDist >= targetDistance) {
                            const segmentProgress = segmentDist > 0 ? (targetDistance - accumulatedDist) / segmentDist : 0;
                            const interpolatedLeft = curr.left + (next.left - curr.left) * Math.min(segmentProgress, 1);
                            cursorPos = { left: interpolatedLeft, top: curr.top };
                            break;
                        }
                        accumulatedDist += segmentDist;
                    }

                    if (!cursorPos) {
                        cursorPos = { left: lineCharPositions[lineCharPositions.length - 1].left, top: lineCharPositions[lineCharPositions.length - 1].top };
                    }

                    const cursor = document.getElementById('globalCursor');
                    if (cursor) {
                        cursor.style.left = cursorPos.left + 'px';
                        cursor.style.top = cursorPos.top + 'px';
                        cursor.style.background = getComputedStyle(document.documentElement).getPropertyValue('--cursor-color').trim();
                    }

                    if (progress < 1) {
                        requestAnimationFrame(updateCursorPosition);
                    } else {
                        lineIdx++;
                        setTimeout(animateNextLine, 300);
                    }
                };

                requestAnimationFrame(updateCursorPosition);
            };

            animateNextLine();
        };

        animatePoemPass();
    }
    
    function renderSocialMediaSloka() {
        if (!isReading || currentSlokaIdx >= slokas.length) {
            // Check if we should loop
            if (currentLoopCount < maxLoops - 1) {
                currentLoopCount++;
                currentSlokaIdx = 0;
                log.info('Looping - starting over', { currentLoop: currentLoopCount + 1, maxLoops });
                setTimeout(() => renderSocialMediaSloka(), 1000);
                return;
            }
            log.info('Social Media rendering complete', { loops: currentLoopCount + 1 });
            return stopReading();
        }

        log.debug('Rendering social media sloka', { index: currentSlokaIdx, total: slokas.length, loop: currentLoopCount + 1 });
        
        const area = document.getElementById('displayArea');
        const entranceType = document.getElementById('entranceSelect')?.value || 'fade';
        
        // Apply exit effect to previous sloka if exists
        const existing = area.querySelector('.sloka-container');
        if (existing) {
            const exitType = document.getElementById('exitSelect')?.value || 'fade';
            existing.classList.add(`${exitType}-transition`);
            setTimeout(() => {
                area.innerHTML = '';
                renderSocialMediaContent(entranceType);
            }, 600);
        } else {
            renderSocialMediaContent(entranceType);
        }
    }
    
    function renderSocialMediaContent(entranceType) {
        const area = document.getElementById('displayArea');
        const container = document.createElement('div');
        container.className = 'sloka-container';

        const sloka = slokas[currentSlokaIdx];
        const charSequence = [];
        
        log.debug('Rendering social media content', { slokaLines: sloka.length, entranceType });

        sloka.forEach((line, lIdx) => {
            const row = document.createElement('div');
            row.className = 'line-row';
            
            if (line.trim() === "") {
                row.style.height = "1.5em";
                container.appendChild(row);
            } else {
                const segments = Array.from(segmenter.segment(line));
                
                // Group characters into words
                let currentWord = [];
                segments.forEach((seg, sIdx) => {
                    if (seg.segment === ' ') {
                        if (currentWord.length > 0) {
                            const wordSpan = document.createElement('span');
                            wordSpan.className = 'word-span';
                            currentWord.forEach(({ segment, id }) => {
                                const span = document.createElement('span');
                                span.className = 'char-span';
                                span.id = id;
                                span.textContent = segment;
                                if (entranceType === 'typewriter') {
                                    span.style.opacity = '0';
                                }
                                wordSpan.appendChild(span);
                                charSequence.push(span.id);
                            });
                            row.appendChild(wordSpan);
                            currentWord = [];
                        }
                        const spaceSpan = document.createElement('span');
                        spaceSpan.className = 'char-span';
                        spaceSpan.id = `sm-c-${lIdx}-space-${sIdx}`;
                        spaceSpan.textContent = ' ';
                        if (entranceType === 'typewriter') {
                            spaceSpan.style.opacity = '0';
                        }
                        row.appendChild(spaceSpan);
                        charSequence.push(spaceSpan.id);
                    } else {
                        currentWord.push({ segment: seg.segment, id: `sm-c-${lIdx}-${sIdx}` });
                    }
                });
                
                if (currentWord.length > 0) {
                    const wordSpan = document.createElement('span');
                    wordSpan.className = 'word-span';
                    currentWord.forEach(({ segment, id }) => {
                        const span = document.createElement('span');
                        span.className = 'char-span';
                        span.id = id;
                        span.textContent = segment;
                        if (entranceType === 'typewriter') {
                            span.style.opacity = '0';
                        }
                        wordSpan.appendChild(span);
                        charSequence.push(span.id);
                    });
                    row.appendChild(wordSpan);
                }
                container.appendChild(row);
            }
        });

        area.appendChild(container);
        log.info('Social media content rendered', { totalChars: charSequence.length });
        
        setTimeout(() => {
            if (entranceType === 'typewriter') {
                container.classList.add('visible');
                animateSocialTypewriter(charSequence);
            } else if (entranceType === 'rolling') {
                container.classList.add('visible');
                animateSocialRolling(container);
            } else {
                container.classList.add('visible');
                container.classList.add(`entrance-${entranceType}`);
                
                // Calculate display duration based on content length and speed
                const speedValue = parseFloat(document.getElementById('speedControl').value);
                const displayDuration = Math.max(3000, charSequence.length * 50 / speedValue);
                
                setTimeout(() => {
                    currentSlokaIdx++;
                    renderSocialMediaSloka();
                }, displayDuration);
            }
        }, 100);
    }
    
    function animateSocialRolling(container) {
        // Get container dimensions after it's rendered
        const containerHeight = container.offsetHeight;
        const viewportHeight = window.innerHeight;
        
        // Start position: below viewport
        const startY = viewportHeight;
        // End position: centered
        const endY = (viewportHeight - containerHeight) / 2;
        const totalDistance = startY - endY;
        
        // Set initial position
        container.style.transform = `translate3d(0, ${startY}px, 0)`;
        container.style.position = 'fixed';
        container.style.left = '50%';
        container.style.transform = `translate(-50%, ${startY}px)`;
        
        const speedValue = parseFloat(document.getElementById('speedControl').value);
        const pixelsPerSecond = 100 * speedValue;
        const duration = (totalDistance / pixelsPerSecond) * 1000;
        const startTime = performance.now();
        
        const animate = (currentTime) => {
            if (!isReading) return;
            
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            const currentY = startY - (totalDistance * progress);
            container.style.transform = `translate(-50%, ${currentY}px)`;
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - stay at center
                container.style.transform = `translate(-50%, ${endY}px)`;
                
                // Calculate display duration
                const charCount = container.textContent.length;
                const displayDuration = Math.max(3000, charCount * 50 / speedValue);
                
                setTimeout(() => {
                    // Reset position before next sloka
                    container.style.position = '';
                    container.style.left = '';
                    container.style.transform = '';
                    currentSlokaIdx++;
                    renderSocialMediaSloka();
                }, displayDuration);
            }
        };
        
        requestAnimationFrame(animate);
    }
    
    function animateSocialTypewriter(charSequence) {
        if (!isReading || charSequence.length === 0) {
            setTimeout(() => {
                currentSlokaIdx++;
                renderSocialMediaSloka();
            }, 1000);
            return;
        }

        const speedValue = parseFloat(document.getElementById('speedControl').value);
        const charDuration = 300 / speedValue;
        let charIdx = 0;

        const typeNextChar = () => {
            if (!isReading || charIdx >= charSequence.length) {
                setTimeout(() => {
                    currentSlokaIdx++;
                    renderSocialMediaSloka();
                }, 1000);
                return;
            }

            const charEl = document.getElementById(charSequence[charIdx]);
            if (charEl) {
                charEl.style.opacity = '1';
            }
            charIdx++;
            setTimeout(typeNextChar, charDuration);
        };

        typeNextChar();
    }

    function renderSloka() {
        if (!isReading || currentSlokaIdx >= slokas.length) {
            log.info('Rendering complete or stopped', { isReading, currentSlokaIdx, totalSlokas: slokas.length });
            return stopReading();
        }

        log.debug('Rendering sloka', { index: currentSlokaIdx, total: slokas.length });
        
        const mode = document.getElementById('modeSelect').value;
        const area = document.getElementById('displayArea');
        
        // Apply transition if previous sloka exists
        const existing = area.querySelector('.sloka-container');
        if (existing) {
            log.debug('Fading out previous sloka');
            const transitionType = document.getElementById('transitionSelect')?.value || 'fade';
            existing.classList.add(`${transitionType}-transition`);
            setTimeout(() => {
                area.innerHTML = '';
                renderSlokaContent();
            }, 600);
        } else {
            area.innerHTML = '';
            renderSlokaContent();
        }
    }

    function renderSlokaContent() {
        const area = document.getElementById('displayArea');
        const container = document.createElement('div');
        container.className = 'sloka-container';

        const charSequence = [];
        const sloka = slokas[currentSlokaIdx];
        
        log.debug('Rendering sloka content', { slokaLines: sloka.length });

        sloka.forEach((line, lIdx) => {
            const row = document.createElement('div');
            row.className = 'line-row';
            
            // Handle empty lines (spacing between slokas)
            if (line.trim() === "") {
                row.style.height = "1.5em";
                container.appendChild(row);
                log.debug('Added empty line', { lineIndex: lIdx });
            } else {
                const segments = Array.from(segmenter.segment(line));
                log.debug('Processing line', { lineIndex: lIdx, segments: segments.length });
                
                // Group characters into words separated by spaces
                let currentWord = [];
                segments.forEach((seg, sIdx) => {
                    if (seg.segment === ' ') {
                        // Render accumulated word
                        if (currentWord.length > 0) {
                            const wordSpan = document.createElement('span');
                            wordSpan.className = 'word-span';
                            currentWord.forEach(({ segment, id }) => {
                                const span = document.createElement('span');
                                span.className = 'char-span';
                                span.id = id;
                                span.textContent = segment;
                                wordSpan.appendChild(span);
                                charSequence.push({ id: span.id, lineIdx: lIdx });
                            });
                            row.appendChild(wordSpan);
                            currentWord = [];
                        }
                        // Add space as individual span
                        const spaceSpan = document.createElement('span');
                        spaceSpan.className = 'char-span';
                        spaceSpan.id = `c-${lIdx}-space-${sIdx}`;
                        spaceSpan.textContent = ' ';
                        row.appendChild(spaceSpan);
                        charSequence.push({ id: spaceSpan.id, lineIdx: lIdx });
                    } else {
                        currentWord.push({ segment: seg.segment, id: `c-${lIdx}-${sIdx}` });
                    }
                });
                
                // Render final word if any
                if (currentWord.length > 0) {
                    const wordSpan = document.createElement('span');
                    wordSpan.className = 'word-span';
                    currentWord.forEach(({ segment, id }) => {
                        const span = document.createElement('span');
                        span.className = 'char-span';
                        span.id = id;
                        span.textContent = segment;
                        wordSpan.appendChild(span);
                        charSequence.push({ id: span.id, lineIdx: lIdx });
                    });
                    row.appendChild(wordSpan);
                }
                container.appendChild(row);
            }
        });

        area.appendChild(container);
        log.info('Sloka content rendered', { totalChars: charSequence.length });
        
        setTimeout(() => {
            container.classList.add('visible');
            animateCursor(charSequence, container);
        }, 100);
    }

    function renderTypewriterSloka() {
        if (!isReading || currentSlokaIdx >= slokas.length) {
            log.info('Typewriter rendering complete or stopped', { isReading, currentSlokaIdx, totalSlokas: slokas.length });
            return stopReading();
        }

        log.debug('Rendering typewriter sloka', { index: currentSlokaIdx, total: slokas.length });
        
        const area = document.getElementById('displayArea');
        
        // Apply transition if previous sloka exists
        const existing = area.querySelector('.sloka-container');
        if (existing) {
            const transitionType = document.getElementById('transitionSelect')?.value || 'fade';
            existing.classList.add(`${transitionType}-transition`);
            setTimeout(() => {
                area.innerHTML = '';
                renderTypewriterContent();
            }, 600);
        } else {
            renderTypewriterContent();
        }
    }

    function renderTypewriterContent() {
        const area = document.getElementById('displayArea');
        const container = document.createElement('div');
        container.className = 'sloka-container typewriter-mode';

        const sloka = slokas[currentSlokaIdx];
        const charSequence = [];
        
        log.debug('Rendering typewriter content', { slokaLines: sloka.length });

        sloka.forEach((line, lIdx) => {
            const row = document.createElement('div');
            row.className = 'line-row';
            
            if (line.trim() === "") {
                row.style.height = "1.5em";
                container.appendChild(row);
            } else {
                const segments = Array.from(segmenter.segment(line));
                
                // Group characters into words separated by spaces
                let currentWord = [];
                segments.forEach((seg, sIdx) => {
                    if (seg.segment === ' ') {
                        // Render accumulated word
                        if (currentWord.length > 0) {
                            const wordSpan = document.createElement('span');
                            wordSpan.className = 'word-span';
                            currentWord.forEach(({ segment, id }) => {
                                const span = document.createElement('span');
                                span.className = 'char-span';
                                span.id = id;
                                span.textContent = segment;
                                span.style.opacity = '0';
                                wordSpan.appendChild(span);
                                charSequence.push(span.id);
                            });
                            row.appendChild(wordSpan);
                            currentWord = [];
                        }
                        // Add space as individual span
                        const spaceSpan = document.createElement('span');
                        spaceSpan.className = 'char-span';
                        spaceSpan.id = `tw-c-${lIdx}-space-${sIdx}`;
                        spaceSpan.textContent = ' ';
                        spaceSpan.style.opacity = '0';
                        row.appendChild(spaceSpan);
                        charSequence.push(spaceSpan.id);
                    } else {
                        currentWord.push({ segment: seg.segment, id: `tw-c-${lIdx}-${sIdx}` });
                    }
                });
                
                // Render final word if any
                if (currentWord.length > 0) {
                    const wordSpan = document.createElement('span');
                    wordSpan.className = 'word-span';
                    currentWord.forEach(({ segment, id }) => {
                        const span = document.createElement('span');
                        span.className = 'char-span';
                        span.id = id;
                        span.textContent = segment;
                        span.style.opacity = '0';
                        wordSpan.appendChild(span);
                        charSequence.push(span.id);
                    });
                    row.appendChild(wordSpan);
                }
                container.appendChild(row);
            }
        });

        area.appendChild(container);
        log.info('Typewriter content rendered', { totalChars: charSequence.length });
        
        setTimeout(() => {
            container.classList.add('visible');
            animateTypewriter(charSequence);
        }, 100);
    }

    function animateTypewriter(charSequence) {
        if (!isReading || charSequence.length === 0) {
            releaseWakeLock();
            setTimeout(() => {
                currentSlokaIdx++;
                renderTypewriterSloka();
            }, 1000);
            return;
        }

        acquireWakeLock();
        const speedValue = parseFloat(document.getElementById('speedControl').value);
        const charDuration = 300 / speedValue; // ms per character (matched to unifocus pace)
        let charIdx = 0;

        const typeNextChar = () => {
            if (!isReading || charIdx >= charSequence.length) {
                releaseWakeLock();
                setTimeout(() => {
                    currentSlokaIdx++;
                    renderTypewriterSloka();
                }, 1000);
                return;
            }

            const charEl = document.getElementById(charSequence[charIdx]);
            if (charEl) {
                charEl.style.opacity = '1';
            }
            charIdx++;
            setTimeout(typeNextChar, charDuration);
        };

        typeNextChar();
    }

    function animateCursor(sequence, container) {
        if (!isReading || sequence.length === 0) {
            releaseWakeLock();
            setTimeout(() => {
                currentSlokaIdx++;
                renderSloka();
            }, 1000);
            return;
        }
        
        // Acquire wake lock for cursor movement
        acquireWakeLock();

        // Create or reuse fixed positioned cursor
        let cursor = document.getElementById('globalCursor');
        if (!cursor) {
            cursor = document.createElement('div');
            cursor.id = 'globalCursor';
            cursor.style.position = 'fixed';
            cursor.style.height = '6px';
            cursor.style.width = '35px';
            cursor.style.borderRadius = '3px';
            cursor.style.zIndex = '100';
            cursor.style.pointerEvents = 'none';
            document.body.appendChild(cursor);
        }

        // Pre-calculate all character positions, only counting distances within lines
        const charPositions = [];
        const distances = [0];
        
        for (let i = 0; i < sequence.length; i++) {
            const charEl = document.getElementById(sequence[i].id);
            if (charEl) {
                const charRect = charEl.getBoundingClientRect();
                charPositions.push({
                    left: charRect.left,
                    top: charRect.bottom - 10
                });
                
                if (i > 0) {
                    const prev = charPositions[i - 1];
                    const curr = charPositions[i];
                    
                    // Only count distance if on same line (Y difference < 5px)
                    if (Math.abs(curr.top - prev.top) <= 5) {
                        const dx = curr.left - prev.left;
                        const distance = Math.abs(dx);
                        distances.push(distances[i - 1] + distance);
                    } else {
                        // New line: distance resets to 0 (no wait at line beginning)
                        distances.push(distances[i - 1]);
                    }
                }
            }
        }

        if (charPositions.length === 0) {
            setTimeout(() => {
                currentSlokaIdx++;
                renderSloka();
            }, 1000);
            return;
        }

        const totalDistance = distances[distances.length - 1];
        const speedValue = parseFloat(document.getElementById('speedControl').value);
        const pixelsPerSecond = 50 * speedValue;
        const totalDuration = (totalDistance / pixelsPerSecond) * 1000;
        const animationStartTime = performance.now();

        const updateCursorPosition = (currentTime) => {
            if (!isReading) return;

            const elapsed = currentTime - animationStartTime;
            const progress = Math.min(elapsed / totalDuration, 1);
            const targetDistance = progress * totalDistance;

            // Find which character segment we're in
            let segmentIdx = 0;
            for (let i = 0; i < distances.length - 1; i++) {
                if (targetDistance >= distances[i] && targetDistance < distances[i + 1]) {
                    segmentIdx = i;
                    break;
                }
            }
            if (targetDistance >= distances[distances.length - 1]) {
                segmentIdx = distances.length - 2;
            }

            const cursor = document.getElementById('globalCursor');
            if (cursor && charPositions.length > 0) {
                const nextIdx = Math.min(segmentIdx + 1, charPositions.length - 1);
                const current = charPositions[segmentIdx];
                const next = charPositions[nextIdx];
                
                // Check if crossing to a new line (instant vertical jump, no interpolation)
                const isNewLine = Math.abs(current.top - next.top) > 5;
                
                if (isNewLine) {
                    // Instantly jump to next line position, no wait
                    cursor.style.left = next.left + 'px';
                    cursor.style.top = next.top + 'px';
                } else {
                    // Same line - smooth horizontal interpolation only
                    const segmentDistance = distances[nextIdx] - distances[segmentIdx];
                    const segmentProgress = segmentDistance > 0 
                        ? (targetDistance - distances[segmentIdx]) / segmentDistance 
                        : 0;
                    
                    const interpolatedLeft = current.left + (next.left - current.left) * segmentProgress;
                    cursor.style.left = interpolatedLeft + 'px';
                    cursor.style.top = current.top + 'px';
                }
                cursor.style.background = getComputedStyle(document.documentElement).getPropertyValue('--cursor-color').trim();
            }

            if (progress < 1) {
                requestAnimationFrame(updateCursorPosition);
            } else {
                // Animation complete
                releaseWakeLock();
                setTimeout(() => {
                    currentSlokaIdx++;
                    renderSloka();
                }, 1000);
            }
        };

        requestAnimationFrame(updateCursorPosition);
    }

    function renderScrollMode() {
        const area = document.getElementById('displayArea');
        area.innerHTML = '';
        
        // Create single cursor for scroll mode
        const globalCursor = document.createElement('div');
        globalCursor.id = 'globalCursor';
        globalCursor.style.position = 'fixed';
        globalCursor.style.height = '6px';
        globalCursor.style.width = '35px';
        globalCursor.style.background = getComputedStyle(document.documentElement).getPropertyValue('--cursor-color').trim();
        globalCursor.style.borderRadius = '3px';
        globalCursor.style.zIndex = '100';
        globalCursor.style.pointerEvents = 'none';
        document.body.appendChild(globalCursor);

        const charSequence = [];

        slokas.forEach((sloka, sIdx) => {
            const container = document.createElement('div');
            container.className = 'sloka-container';
            container.id = `sloka-${sIdx}`;
            
            sloka.forEach((line, lIdx) => {
                const row = document.createElement('div');
                row.className = 'line-row';
                
                if (line.trim() === "") {
                    row.style.height = "1.5em";
                    container.appendChild(row);
                } else {
                    const segments = Array.from(segmenter.segment(line));
                    segments.forEach((seg, segIdx) => {
                        const span = document.createElement('span');
                        span.className = 'char-span';
                        span.id = `scroll-c-${sIdx}-${lIdx}-${segIdx}`;
                        span.textContent = seg.segment;
                        row.appendChild(span);
                        charSequence.push(span.id);
                    });
                    container.appendChild(row);
                }
            });
            area.appendChild(container);
        });

        setTimeout(() => {
            animateScrollCursor(charSequence);
        }, 100);
    }

    function animateScrollCursor(sequence) {
        if (!isReading || sequence.length === 0) {
            const cursor = document.getElementById('globalCursor');
            if (cursor) cursor.remove();
            releaseWakeLock();
            return stopReading();
        }
        
        // Acquire wake lock for cursor movement
        acquireWakeLock();

        // Pre-calculate all character positions, only counting distances within lines
        const charPositions = [];
        const distances = [0];
        
        for (let i = 0; i < sequence.length; i++) {
            const charEl = document.getElementById(sequence[i]);
            if (charEl) {
                const charRect = charEl.getBoundingClientRect();
                charPositions.push({
                    left: charRect.left,
                    top: charRect.bottom - 10
                });
                
                if (i > 0) {
                    const prev = charPositions[i - 1];
                    const curr = charPositions[i];
                    
                    // Only count distance if on same line (Y difference < 5px)
                    if (Math.abs(curr.top - prev.top) <= 5) {
                        const dx = curr.left - prev.left;
                        const distance = Math.abs(dx);
                        distances.push(distances[i - 1] + distance);
                    } else {
                        // New line: distance resets to 0 (no wait at line beginning)
                        distances.push(distances[i - 1]);
                    }
                }
            }
        }

        if (charPositions.length === 0) {
            const cursor = document.getElementById('globalCursor');
            if (cursor) cursor.remove();
            return stopReading();
        }

        const totalDistance = distances[distances.length - 1];
        const speedValue = parseFloat(document.getElementById('speedControl').value);
        const pixelsPerSecond = 50 * speedValue; // Higher speed value = faster movement
        const totalDuration = (totalDistance / pixelsPerSecond) * 1000; // in milliseconds
        const animationStartTime = performance.now();

        const updateCursorPosition = (currentTime) => {
            if (!isReading) return;

            const elapsed = currentTime - animationStartTime;
            const progress = Math.min(elapsed / totalDuration, 1);
            const targetDistance = progress * totalDistance;

            // Find which character segment we're in
            let segmentIdx = 0;
            for (let i = 0; i < distances.length - 1; i++) {
                if (targetDistance >= distances[i] && targetDistance < distances[i + 1]) {
                    segmentIdx = i;
                    break;
                }
            }
            if (targetDistance >= distances[distances.length - 1]) {
                segmentIdx = distances.length - 2;
            }

            const cursor = document.getElementById('globalCursor');
            if (cursor && charPositions.length > 0) {
                const nextIdx = Math.min(segmentIdx + 1, charPositions.length - 1);
                const current = charPositions[segmentIdx];
                const next = charPositions[nextIdx];
                
                // Check if crossing to a new line (instant vertical jump, no interpolation)
                const isNewLine = Math.abs(current.top - next.top) > 5;
                
                if (isNewLine) {
                    // Instantly jump to next line position, no wait
                    cursor.style.left = next.left + 'px';
                    cursor.style.top = next.top + 'px';
                } else {
                    // Same line - smooth horizontal interpolation only
                    const segmentDistance = distances[nextIdx] - distances[segmentIdx];
                    const segmentProgress = segmentDistance > 0 
                        ? (targetDistance - distances[segmentIdx]) / segmentDistance 
                        : 0;
                    
                    const interpolatedLeft = current.left + (next.left - current.left) * segmentProgress;
                    cursor.style.left = interpolatedLeft + 'px';
                    cursor.style.top = current.top + 'px';
                }
                cursor.style.background = getComputedStyle(document.documentElement).getPropertyValue('--cursor-color').trim();
            }

            if (progress < 1) {
                requestAnimationFrame(updateCursorPosition);
            } else {
                // Animation complete
                const cursor = document.getElementById('globalCursor');
                if (cursor) cursor.remove();
                releaseWakeLock();
                stopReading();
            }
        };

        requestAnimationFrame(updateCursorPosition);
    }

    function renderRollingMode(text) {
        const area = document.getElementById('displayArea');
        area.innerHTML = '';
        
        // Parse text preserving all formatting including empty lines
        const lines = text.split('\n');
        log.debug('Rolling mode text parsed', { totalLines: lines.length });
        
        // Find the last non-empty line
        let lastNonEmptyIdx = -1;
        for (let i = lines.length - 1; i >= 0; i--) {
            if (lines[i].trim() !== '') {
                lastNonEmptyIdx = i;
                break;
            }
        }
        
        // Take the last 15 lines (or all if less than 15) to preserve all spacing before credits
        const creditBlockStart = Math.max(0, lastNonEmptyIdx - 14);
        
        const container = document.createElement('div');
        container.className = 'rolling-container';
        container.id = 'rolling-container';
        
        // Create line elements for all lines
        lines.forEach((line, idx) => {
            const lineDiv = document.createElement('div');
            lineDiv.className = 'rolling-line';
            lineDiv.id = `rolling-line-${idx}`;
            lineDiv.setAttribute('data-line-index', idx);
            
            if (line.trim() === '') {
                lineDiv.classList.add('empty');
                lineDiv.innerHTML = '&nbsp;'; // Use non-breaking space to preserve height
            } else {
                lineDiv.textContent = line;
            }
            
            container.appendChild(lineDiv);
        });
        
        area.appendChild(container);
        
        // Start position: container begins off-screen at the bottom
        container.style.transform = `translate3d(0, ${window.innerHeight}px, 0)`;
        
        // Calculate total height - wait for layout
        setTimeout(() => {
            const totalHeight = container.scrollHeight;
            const viewportHeight = window.innerHeight;
            
            // Find the position where the last non-empty line will be at center
            const lastLineEl = container.querySelector(`[data-line-index="${lastNonEmptyIdx}"]`);
            const lastLineOffsetTop = lastLineEl ? lastLineEl.offsetTop : totalHeight;
            const lastLineHeight = lastLineEl ? lastLineEl.offsetHeight : 0;
            
            log.debug('Rolling mode dimensions', { totalHeight, viewportHeight, creditBlockStart, lastNonEmptyIdx, lastLineOffsetTop });
            
            // Start animation: scroll from bottom until last line reaches center
            animateRollingCredits(container, totalHeight, viewportHeight, lastLineOffsetTop, lastLineHeight);
        }, 50);
    }

    function animateRollingCredits(container, totalHeight, viewportHeight, lastLineOffsetTop, lastLineHeight) {
        if (!isReading) return;
        
        const speedValue = parseFloat(document.getElementById('speedControl').value);
        const pixelsPerSecond = 50 * speedValue;
        
        // Start: container at bottom (viewportHeight)
        // End: last line center aligned = container top at (viewportHeight/2 - lastLineOffsetTop - lastLineHeight/2)
        const startY = viewportHeight;
        const endY = (viewportHeight / 2) - lastLineOffsetTop - (lastLineHeight / 2);
        const totalScrollDistance = startY - endY;
        const duration = (totalScrollDistance / pixelsPerSecond) * 1000; // in ms
        const startTime = performance.now();
        
        log.debug('Rolling animation started', { startY, endY, totalDistance: totalScrollDistance, duration, speed: speedValue });
        
        const animate = (currentTime) => {
            if (!isReading) return;
            
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Linear scroll for rolling credits
            const currentY = startY - (totalScrollDistance * progress);
            const roundedY = Math.round(currentY * 10) / 10;
            container.style.transform = `translate3d(0, ${roundedY}px, 0)`;
            
            // Keep wake lock active while rolling
            if (!wakeLock && navigator.wakeLock) {
                acquireWakeLock();
            }
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - last line is centered
                container.style.transform = `translate3d(0, ${endY}px, 0)`;
                const displayArea = document.getElementById('displayArea');
                if (displayArea) {
                    displayArea.style.setProperty('--bg-image-opacity', '1');
                }
                log.info('Rolling animation completed - last line centered');
                
                setTimeout(() => {
                    if (isReading) {
                        stopReading();
                    }
                }, 5000);
            }
        };
        
        requestAnimationFrame(animate);
    }
    
    function stopReading() {
        log.info('Stopping reading session', { currentSloka: currentSlokaIdx, wasReading: isReading });
        
        isReading = false;
        clearTimeout(charTimeout);
        document.body.classList.remove('reading-active');
        const displayArea = document.getElementById('displayArea');
        if (displayArea) {
            displayArea.innerHTML = '';
            displayArea.style.setProperty('--bg-image-opacity', '0.3');
        }
        
        // Remove cursor element
        const cursor = document.getElementById('globalCursor');
        if (cursor) {
            cursor.remove();
            log.debug('Global cursor removed');
        }
        
        // Release screen wake lock
        releaseWakeLock();
        
        log.info('Reading session stopped successfully');
    }

    // Update font size in real-time with slider
    document.getElementById('fontSizeControl')?.addEventListener('input', (e) => {
        document.documentElement.style.setProperty('--font-size', e.target.value + 'px');
        document.getElementById('fontSizeValue').textContent = e.target.value;
        log.debug('Font size changed', { newSize: e.target.value });
    });

    // Update speed display
    document.getElementById('speedControl')?.addEventListener('input', (e) => {
        document.getElementById('speedValue').textContent = e.target.value;
        log.debug('Speed changed', { newSpeed: e.target.value });
    });

    // Update colors in real-time
    document.getElementById('bgPicker')?.addEventListener('input', (e) => {
        document.documentElement.style.setProperty('--bg-color', e.target.value);
        document.body.style.background = e.target.value;
        log.debug('Background color changed', { newColor: e.target.value });
        const brandingEl = document.getElementById('branding-watermark');
        const isLightBg = getLuminance(e.target.value) > 128;
        if (brandingEl) brandingEl.style.color = isLightBg ? '#000000' : '#FFFFFF';
    });

    document.getElementById('textPicker')?.addEventListener('input', (e) => {
        document.documentElement.style.setProperty('--text-color', e.target.value);
        document.body.style.color = e.target.value;
        log.debug('Text color changed', { newColor: e.target.value });
    });

    document.getElementById('cursorPicker')?.addEventListener('input', (e) => {
        document.documentElement.style.setProperty('--cursor-color', e.target.value);
        log.debug('Cursor color changed', { newColor: e.target.value });
    });

    // Text alignment
    document.getElementById('alignmentSelect')?.addEventListener('change', (e) => {
        document.documentElement.style.setProperty('--text-align', e.target.value);
        log.debug('Text alignment changed', { newAlignment: e.target.value });
    });

    // Tab recording controls
    document.getElementById('recordStartBtn')?.addEventListener('click', () => {
        updateRecordingStatus('Starting...');
        startTabRecording();
    });
    document.getElementById('recordStopBtn')?.addEventListener('click', () => {
        updateRecordingStatus('Stopping...');
        stopTabRecording();
    });

    // Portrait preview mode (9:16)
    document.getElementById('portraitModeToggle')?.addEventListener('change', (e) => {
        if (e.target.checked) {
            document.body.classList.add('portrait-mode');
        } else {
            document.body.classList.remove('portrait-mode');
        }
    });
    
    // Loop count display
    document.getElementById('loopControl')?.addEventListener('input', (e) => {
        document.getElementById('loopValue').textContent = e.target.value;
        log.debug('Loop count changed', { newLoop: e.target.value });
    });
    
    // Mode selection - show/hide relevant options
    document.getElementById('modeSelect')?.addEventListener('change', (e) => {
        const mode = e.target.value;
        const transitionOption = document.getElementById('transitionOption');
        const entranceOption = document.getElementById('entranceOption');
        const exitOption = document.getElementById('exitOption');
        const loopOption = document.getElementById('loopOption');
        const textEffectsOption = document.getElementById('textEffectsOption');
        const fontStyleOption = document.getElementById('fontStyleOption');
        
        if (mode === 'social') {
            transitionOption.style.display = 'none';
            entranceOption.style.display = '';
            exitOption.style.display = '';
            loopOption.style.display = '';
            textEffectsOption.style.display = '';
            fontStyleOption.style.display = 'none';
        } else if (mode === 'kids') {
            transitionOption.style.display = 'none';
            entranceOption.style.display = 'none';
            exitOption.style.display = 'none';
            loopOption.style.display = 'none';
            textEffectsOption.style.display = 'none';
            fontStyleOption.style.display = '';
        } else {
            transitionOption.style.display = '';
            entranceOption.style.display = 'none';
            exitOption.style.display = 'none';
            loopOption.style.display = 'none';
            textEffectsOption.style.display = 'none';
            fontStyleOption.style.display = 'none';
        }
        
        log.debug('Mode changed', { newMode: mode });
    });

    // Font style for Kids mode
    document.getElementById('fontStyleSelect')?.addEventListener('change', () => {
        applyKidsFontStyle();
    });

    // Background image handling
    const bgImageInput = document.getElementById('bgImageInput');
    const bgOpacity = document.getElementById('bgOpacity');
    const bgPosition = document.getElementById('bgPosition');
    const bgSize = document.getElementById('bgSize');

    bgImageInput?.addEventListener('change', (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async (event) => {
            const imageData = event.target?.result;
            if (imageData) {
                try {
                    const compressed = await compressImage(imageData);
                    saveBackgroundImage(compressed);
                    applyBackgroundImage(compressed);
                    log.info('Background image loaded and compressed');
                } catch (err) {
                    log.error('Failed to process background image', err);
                }
            }
        };
        reader.readAsDataURL(file);
    });

    bgOpacity?.addEventListener('input', (e) => {
        document.getElementById('bgOpacityValue').textContent = e.target.value;
        const saved = localStorage.getItem('slokaReader.bgImage.v1');
        if (saved) {
            applyBackgroundImage(saved);
        }
        log.debug('Background opacity changed', { newOpacity: e.target.value });
    });

    bgPosition?.addEventListener('change', (e) => {
        const saved = localStorage.getItem('slokaReader.bgImage.v1');
        if (saved) {
            applyBackgroundImage(saved);
        }
        log.debug('Background position changed', { newPosition: e.target.value });
    });

    bgSize?.addEventListener('change', (e) => {
        const saved = localStorage.getItem('slokaReader.bgImage.v1');
        if (saved) {
            applyBackgroundImage(saved);
        }
        log.debug('Background size changed', { newSize: e.target.value });
    });

    // Draft persistence + unsaved changes warning
    const textInputEl = document.getElementById('textInput');
    textInputEl?.addEventListener('input', (e) => {
        hasUnsavedChanges = true;
        saveDraft(e.target.value);
    });

    const sampleToggleEl = document.getElementById('useSampleText');
    sampleToggleEl?.addEventListener('change', (e) => {
        if (!textInputEl) return;
        if (e.target.checked) {
            if (textInputEl.value.trim().length === 0) {
                textInputEl.value = SAMPLE_TEXT;
                saveDraft(textInputEl.value);
                hasUnsavedChanges = false;
            }
        } else if (textInputEl.value === SAMPLE_TEXT) {
            textInputEl.value = '';
            saveDraft('');
            hasUnsavedChanges = false;
        }
    });

    window.addEventListener('beforeunload', (e) => {
        const currentText = textInputEl ? textInputEl.value.trim() : '';
        const isDraftDirty = hasUnsavedChanges || (currentText.length > 0 && currentText !== lastDraftText);
        if (!isDraftDirty) return;
        e.preventDefault();
        e.returnValue = '';
    });

    window.addEventListener('pagehide', () => {
        if (textInputEl) saveDraft(textInputEl.value);
    });

    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden' && textInputEl) {
            saveDraft(textInputEl.value);
        }
    });

    function revealResetTemporarily() {
        if (!isReading) return;
        if (Date.now() - readingStartTime < 2000) return;
        document.body.classList.add('show-reset');
        if (resetRevealTimeout) {
            clearTimeout(resetRevealTimeout);
        }
        resetRevealTimeout = setTimeout(() => {
            document.body.classList.remove('show-reset');
        }, 2000);
    }

    // Show reset on any hover/touch during reading
    document.addEventListener('mousemove', revealResetTemporarily);
    document.addEventListener('touchstart', revealResetTemporarily, { passive: true });

    // Branding toggle
    document.getElementById('showBranding')?.addEventListener('change', (e) => {
        const brandingEl = document.getElementById('branding-watermark');
        if (e.target.checked) {
            brandingEl.classList.remove('hidden');
            log.debug('Branding shown');
        } else {
            brandingEl.classList.add('hidden');
            log.debug('Branding hidden');
        }
    });

    // Set responsive defaults on page load
    window.addEventListener('DOMContentLoaded', () => {
        const width = window.innerWidth;
        let defaultFontSize = 42;
        
        if (width <= 480) {
            defaultFontSize = 22;
        } else if (width <= 768) {
            defaultFontSize = 28;
        }
        
        document.getElementById('fontSizeControl').value = defaultFontSize;
        document.getElementById('fontSizeValue').textContent = defaultFontSize;
        document.documentElement.style.setProperty('--font-size', defaultFontSize + 'px');
        
        const sampleOptionEl = document.getElementById('sampleTextOption');
        if (sampleOptionEl && window.location.protocol === 'file:') {
            sampleOptionEl.style.display = '';
        }

        restoreDraftIfAvailable();
        applySampleTextIfRequested();
        restoreBackgroundImage();
        log.info('Responsive defaults set', { screenWidth: width, fontSize: defaultFontSize });
    });

    // Register Service Worker for PWA functionality
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js')
                .then((registration) => {
                    log.info('Service Worker registered successfully', { scope: registration.scope });
                })
                .catch((error) => {
                    log.error('Service Worker registration failed', error);
                });
        });
    } else {
        log.warn('Service Worker not supported in this browser');
    }

</script>
</body>
</html>
