<!DOCTYPE html>
<html lang="te">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a73e8">
    <meta name="description" content="Smooth cursor-based Sanskrit sloka reader with customizable fonts, colors, and reading speeds">
    <title>‡∞¶‡±É‡∞∑‡±ç‡∞ü‡∞ø‡∞™‡∞•‡∞Ç</title>
    <link rel="manifest" href="./manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'><rect fill='%231a73e8' width='192' height='192'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-size='100' fill='white' font-family='Arial' font-weight='bold'>üìñ</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'><rect fill='%231a73e8' width='180' height='180' rx='40'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-size='90' fill='white' font-family='Arial' font-weight='bold'>üìñ</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=NTR&display=swap" rel="stylesheet">
    
    <style>
        :root { --bg-color: #f4f7f6; --text-color: #111111; --cursor-color: #1a73e8; --font-size: 42px; }
        
        /* Responsive font sizing */
        @media (max-width: 768px) {
            :root { --font-size: 28px; }
        }
        @media (max-width: 480px) {
            :root { --font-size: 22px; }
        }
        body { font-family: 'NTR', sans-serif; background: var(--bg-color); color: var(--text-color); margin: 0; overflow-x: hidden; }
        .settings-container { width: 90%; max-width: 850px; margin: 20px auto; background: white; padding: 25px; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
        body.reading-active .settings-container { display: none; }
        textarea { width: 100%; min-height: 180px; margin-bottom: 20px; padding: 15px; font-size: 18px; border: 2px solid #e0e0e0; border-radius: 10px; }
        .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .option-group { background: #fdfdfd; padding: 12px; border-radius: 10px; border: 1px solid #eee; display: flex; flex-direction: column; gap: 8px; }
        
        /* The container MUST be position: relative for the cursor to align to it */
        .sloka-container { position: relative; width: 100%; max-width: 800px; margin: 0 auto 40px; opacity: 0; transition: opacity 0.5s blur; filter: blur(0px); }
        .sloka-container.visible { opacity: 1; }
        .sloka-container.fade-out { opacity: 0; filter: blur(8px); }
        
        .line-row { display: block; white-space: normal; word-wrap: break-word; margin-bottom: 16px; min-height: 1.2em; position: relative; }
        .char-span { font-size: var(--font-size); display: inline-block; white-space: pre; line-height: 1.4; position: relative; }
        
        #displayArea { display: none; justify-content: center; align-items: center; min-height: 100vh; padding: 10vh 20px; box-sizing: border-box; }
        body.reading-active #displayArea { display: flex; }
        
        #globalCursor { 
            position: absolute; height: 6px; width: 35px; background: var(--cursor-color);
            border-radius: 3px; z-index: 100;
            pointer-events: none;
        }

        .slider-group { display: flex; align-items: center; gap: 10px; }
        .slider-group input[type="range"] { flex: 1; }
        .slider-group .value-display { min-width: 35px; font-weight: bold; color: var(--text-color); }

        .color-controls { display: flex; gap: 10px; align-items: center; }
        .color-controls input[type="color"] { width: 50px; height: 40px; border: none; border-radius: 6px; cursor: pointer; }

        #displayArea.scroll-mode { display: flex; flex-direction: column; padding: 40px 20px; overflow-y: hidden; height: 100vh; justify-content: flex-start; align-items: center; }
        #displayArea.scroll-mode .sloka-container { margin-bottom: 40px; opacity: 1 !important; animation: pageBlurIn 0.5s ease-in-out; }

        @keyframes pageBlurIn {
            0% {
                opacity: 0;
                filter: blur(10px);
            }
            100% {
                opacity: 1;
                filter: blur(0px);
            }
        }

        #stopBtn { position: fixed; bottom: 30px; right: 30px; background: #ea4335; color: white; border: none; padding: 15px 30px; border-radius: 50px; cursor: pointer; display: none; z-index: 1000; }
    </style>
</head>
<body>

<div class="settings-container">
    <h2 style="text-align:center;">‡∞¶‡±É‡∞∑‡±ç‡∞ü‡∞ø‡∞™‡∞•‡∞Ç 2026</h2>
    <textarea id="textInput">
‡∞∂‡±Å‡∞ï‡±ç‡∞≤‡∞æ‡∞Ç ‡∞¨‡∞∞‡∞ß‡∞∞‡∞Ç-‡∞µ‡∞ø‡∞Ä‡∞∑‡±ç‡∞£‡±Å‡∞Ç ‡∞∂‡∞∂‡∞ø‡∞µ‡∞∞‡±ç‡∞£‡∞Ç ‡∞ö‡∞§‡±Å‡∞∞‡±ç‡∞≠‡±Å‡∞ú‡∞Æ‡±ç ‡•§
‡∞™‡±ç‡∞∞‡∞∏‡∞®‡±ç‡∞®‡∞µ‡∞¶‡∞®‡∞Ç ‡∞ß‡±ç‡∞Ø‡∞æ‡∞Ø‡±á‡∞§‡±ç ‡∞∏‡∞∞‡±ç‡∞µ ‡∞µ‡∞ø‡∞ò‡±ç‡∞®‡±ã‡∞™‡∞∂‡∞æ‡∞Ç‡∞§‡∞Ø‡±á
‡∞Ø‡∞∏‡±ç‡∞Ø‡∞¶‡±ç‡∞µ‡∞ø‡∞∞‡∞¶ ‡∞µ‡∞ï‡±ç‡∞§‡±ç‡∞∞‡∞æ‡∞¶‡±ç‡∞Ø‡∞æ‡∞É ‡∞™‡∞æ‡∞∞‡∞ø‡∞∑‡∞¶‡±ç‡∞Ø‡∞æ‡∞É ‡∞™‡∞∞‡∞∂‡±ç‡∞∂‡∞§‡∞Æ‡±ç ‡•§
‡∞µ‡∞ø‡∞ò‡±ç‡∞®‡∞Ç ‡∞®‡∞ø‡∞ò‡±ç‡∞®‡∞Ç‡∞§‡±Å ‡∞∏‡∞§‡∞§‡∞Ç-‡∞µ‡∞ø‡∞Ä‡∞∑‡±ç‡∞µ‡∞ï‡±ç‡∞∏‡±á‡∞®‡∞Ç ‡∞§‡∞Æ‡∞æ‡∞∂‡±ç‡∞∞‡∞Ø‡±á ‡••

‡∞∂‡±Å‡∞ï‡±ç‡∞≤‡∞æ‡∞Ç ‡∞¨‡∞∞‡∞ß‡∞∞‡∞Ç-‡∞µ‡∞ø‡∞Ä‡∞∑‡±ç‡∞£‡±Å‡∞Ç ‡∞∂‡∞∂‡∞ø‡∞µ‡∞∞‡±ç‡∞£‡∞Ç ‡∞ö‡∞§‡±Å‡∞∞‡±ç‡∞≠‡±Å‡∞ú‡∞Æ‡±ç ‡•§
‡∞™‡±ç‡∞∞‡∞∏‡∞®‡±ç‡∞®‡∞µ‡∞¶‡∞®‡∞Ç ‡∞ß‡±ç‡∞Ø‡∞æ‡∞Ø‡±á‡∞§‡±ç ‡∞∏‡∞∞‡±ç‡∞µ ‡∞µ‡∞ø‡∞ò‡±ç‡∞®‡±ã‡∞™‡∞∂‡∞æ‡∞Ç‡∞§‡∞Ø‡±á
‡∞Ø‡∞∏‡±ç‡∞Ø‡∞¶‡±ç‡∞µ‡∞ø‡∞∞‡∞¶ ‡∞µ‡∞ï‡±ç‡∞§‡±ç‡∞∞‡∞æ‡∞¶‡±ç‡∞Ø‡∞æ‡∞É ‡∞™‡∞æ‡∞∞‡∞ø‡∞∑‡∞¶‡±ç‡∞Ø‡∞æ‡∞É ‡∞™‡∞∞‡∞∂‡±ç‡∞∂‡∞§‡∞Æ‡±ç ‡•§
‡∞µ‡∞ø‡∞ò‡±ç‡∞®‡∞Ç ‡∞®‡∞ø‡∞ò‡±ç‡∞®‡∞Ç‡∞§‡±Å ‡∞∏‡∞§‡∞§‡∞Ç-‡∞µ‡∞ø‡∞Ä‡∞∑‡±ç‡∞µ‡∞ï‡±ç‡∞∏‡±á‡∞®‡∞Ç ‡∞§‡∞Æ‡∞æ‡∞∂‡±ç‡∞∞‡∞Ø‡±á ‡••

</textarea>
    <div class="controls">
        <div class="option-group"><span>Mode</span>
            <select id="modeSelect">
                <option value="unifocus">UniFocus Mode</option>
                <option value="scroll" selected>Continuous Mode</option>
            </select>
        </div>
        <div class="option-group">
            <span>Font Size</span>
            <div class="slider-group">
                <input type="range" id="fontSizeControl" min="16" max="80" value="42">
                <span class="value-display" id="fontSizeValue">42</span>
            </div>
        </div>
        <div class="option-group">
            <span>Speed</span>
            <div class="slider-group">
                <input type="range" id="speedControl" min="0.5" max="12" step="0.5" value="1">
                <span class="value-display" id="speedValue">1</span>
            </div>
        </div>
        <div class="option-group">
            <span>Colors</span>
            <div class="color-controls">
                <input type="color" id="bgPicker" value="#f4f7f6" title="Background Color">
                <input type="color" id="textPicker" value="#111111" title="Text Color">
                <input type="color" id="cursorPicker" value="#1a73e8" title="Cursor Color">
            </div>
        </div>
    </div>
    <button onclick="startReading()" style="width:100%; padding:15px; background:#34a853; color:white; border:none; border-radius:8px; cursor:pointer;">Start Reading</button>
</div>

<button id="stopBtn" onclick="stopReading()">Reset</button>
<div id="displayArea"></div>

<script>
    let slokas = [], currentSlokaIdx = 0, isReading = false, charTimeout = null;
    const segmenter = new Intl.Segmenter('te', { granularity: 'grapheme' });

    // Logging system
    const log = {
        info: (msg, data = null) => {
            console.log(`[INFO] ${new Date().toISOString().substr(11, 12)} - ${msg}`, data || '');
        },
        debug: (msg, data = null) => {
            console.debug(`[DEBUG] ${new Date().toISOString().substr(11, 12)} - ${msg}`, data || '');
        },
        error: (msg, data = null) => {
            console.error(`[ERROR] ${new Date().toISOString().substr(11, 12)} - ${msg}`, data || '');
        },
        warn: (msg, data = null) => {
            console.warn(`[WARN] ${new Date().toISOString().substr(11, 12)} - ${msg}`, data || '');
        }
    };

    log.info('Application initialized');
    log.debug('Segmenter created for Telugu', { granularity: 'grapheme' });

    function parseSlokas(text) {
        log.debug('Parsing slokas from text', { textLength: text.length });
        
        // Split by || or double newlines
        let parts = text.split(/\|\||\n\s*\n/);
        const result = parts
            .map(part => part.trim())
            .filter(part => part.length > 0)
            .map(part => part.split('\n'));
            
        log.info('Slokas parsed successfully', { count: result.length, totalLines: result.reduce((sum, sloka) => sum + sloka.length, 0) });
        return result;
    }

    function startReading() {
        const text = document.getElementById('textInput').value.trim();
        if (!text) {
            log.warn('Start reading called with empty text');
            return;
        }

        log.info('Starting reading session');
        
        // Update CSS variables from color pickers
        const bgColor = document.getElementById('bgPicker').value;
        const textColor = document.getElementById('textPicker').value;
        const cursorColor = document.getElementById('cursorPicker').value;
        const fontSize = document.getElementById('fontSizeControl').value;
        
        document.documentElement.style.setProperty('--bg-color', bgColor);
        document.documentElement.style.setProperty('--text-color', textColor);
        document.documentElement.style.setProperty('--cursor-color', cursorColor);
        document.documentElement.style.setProperty('--font-size', fontSize + 'px');
        document.body.style.background = bgColor;
        document.body.style.color = textColor;
        
        log.debug('UI settings applied', { bgColor, textColor, cursorColor, fontSize });

        const mode = document.getElementById('modeSelect').value;
        log.info('Reading mode selected', { mode });
        
        if (mode === 'unifocus') {
            slokas = parseSlokas(text);
            currentSlokaIdx = 0;
            isReading = true;
            document.body.classList.add('reading-active');
            document.getElementById('stopBtn').style.display = 'block';
            document.getElementById('displayArea').classList.remove('scroll-mode');
            log.info('Starting UniFocus mode');
            renderSloka();
        } else {
            // Continuous scroll mode
            slokas = parseSlokas(text);
            currentSlokaIdx = 0;
            isReading = true;
            document.body.classList.add('reading-active');
            document.getElementById('stopBtn').style.display = 'block';
            document.getElementById('displayArea').classList.add('scroll-mode');
            log.info('Starting Continuous mode');
            renderScrollMode();
        }
    }

    function renderSloka() {
        if (!isReading || currentSlokaIdx >= slokas.length) {
            log.info('Rendering complete or stopped', { isReading, currentSlokaIdx, totalSlokas: slokas.length });
            return stopReading();
        }

        log.debug('Rendering sloka', { index: currentSlokaIdx, total: slokas.length });
        
        const mode = document.getElementById('modeSelect').value;
        const area = document.getElementById('displayArea');
        
        // Fade out previous sloka if it exists
        const existing = area.querySelector('.sloka-container');
        if (existing) {
            log.debug('Fading out previous sloka');
            existing.classList.add('fade-out');
            setTimeout(() => {
                area.innerHTML = '';
                renderSlokaContent();
            }, 500);
        } else {
            area.innerHTML = '';
            renderSlokaContent();
        }
    }

    function renderSlokaContent() {
        const area = document.getElementById('displayArea');
        const container = document.createElement('div');
        container.className = 'sloka-container';

        const charSequence = [];
        const sloka = slokas[currentSlokaIdx];
        
        log.debug('Rendering sloka content', { slokaLines: sloka.length });

        sloka.forEach((line, lIdx) => {
            const row = document.createElement('div');
            row.className = 'line-row';
            
            // Handle empty lines (spacing between slokas)
            if (line.trim() === "") {
                row.style.height = "1.5em";
                container.appendChild(row);
                log.debug('Added empty line', { lineIndex: lIdx });
            } else {
                const segments = Array.from(segmenter.segment(line));
                log.debug('Processing line', { lineIndex: lIdx, segments: segments.length });
                
                segments.forEach((seg, sIdx) => {
                    const span = document.createElement('span');
                    span.className = 'char-span';
                    span.id = `c-${lIdx}-${sIdx}`;
                    span.textContent = seg.segment;
                    row.appendChild(span);
                    charSequence.push({ id: span.id, lineIdx: lIdx });
                });
                container.appendChild(row);
            }
        });

        area.appendChild(container);
        log.info('Sloka content rendered', { totalChars: charSequence.length });
        
        setTimeout(() => {
            container.classList.add('visible');
            animateCursor(charSequence, container);
        }, 100);
    }

    function animateCursor(sequence, container) {
        if (!isReading || sequence.length === 0) {
            setTimeout(() => {
                currentSlokaIdx++;
                renderSloka();
            }, 1000);
            return;
        }

        // Create or reuse fixed positioned cursor
        let cursor = document.getElementById('globalCursor');
        if (!cursor) {
            cursor = document.createElement('div');
            cursor.id = 'globalCursor';
            cursor.style.position = 'fixed';
            cursor.style.height = '6px';
            cursor.style.width = '35px';
            cursor.style.borderRadius = '3px';
            cursor.style.zIndex = '100';
            cursor.style.pointerEvents = 'none';
            document.body.appendChild(cursor);
        }

        // Pre-calculate all character positions, only counting distances within lines
        const charPositions = [];
        const distances = [0];
        
        for (let i = 0; i < sequence.length; i++) {
            const charEl = document.getElementById(sequence[i].id);
            if (charEl) {
                const charRect = charEl.getBoundingClientRect();
                charPositions.push({
                    left: charRect.left,
                    top: charRect.bottom - 4
                });
                
                if (i > 0) {
                    const prev = charPositions[i - 1];
                    const curr = charPositions[i];
                    
                    // Only count distance if on same line (Y difference < 5px)
                    if (Math.abs(curr.top - prev.top) <= 5) {
                        const dx = curr.left - prev.left;
                        const distance = Math.abs(dx);
                        distances.push(distances[i - 1] + distance);
                    } else {
                        // New line: distance resets to 0 (no wait at line beginning)
                        distances.push(distances[i - 1]);
                    }
                }
            }
        }

        if (charPositions.length === 0) {
            setTimeout(() => {
                currentSlokaIdx++;
                renderSloka();
            }, 1000);
            return;
        }

        const totalDistance = distances[distances.length - 1];
        const speedValue = parseInt(document.getElementById('speedControl').value);
        const pixelsPerSecond = 100 * speedValue;
        const totalDuration = (totalDistance / pixelsPerSecond) * 1000;
        const animationStartTime = performance.now();

        const updateCursorPosition = (currentTime) => {
            if (!isReading) return;

            const elapsed = currentTime - animationStartTime;
            const progress = Math.min(elapsed / totalDuration, 1);
            const targetDistance = progress * totalDistance;

            // Find which character segment we're in
            let segmentIdx = 0;
            for (let i = 0; i < distances.length - 1; i++) {
                if (targetDistance >= distances[i] && targetDistance < distances[i + 1]) {
                    segmentIdx = i;
                    break;
                }
            }
            if (targetDistance >= distances[distances.length - 1]) {
                segmentIdx = distances.length - 2;
            }

            const cursor = document.getElementById('globalCursor');
            if (cursor && charPositions.length > 0) {
                const nextIdx = Math.min(segmentIdx + 1, charPositions.length - 1);
                const current = charPositions[segmentIdx];
                const next = charPositions[nextIdx];
                
                // Check if crossing to a new line (instant vertical jump, no interpolation)
                const isNewLine = Math.abs(current.top - next.top) > 5;
                
                if (isNewLine) {
                    // Instantly jump to next line position, no wait
                    cursor.style.left = next.left + 'px';
                    cursor.style.top = next.top + 'px';
                } else {
                    // Same line - smooth horizontal interpolation only
                    const segmentDistance = distances[nextIdx] - distances[segmentIdx];
                    const segmentProgress = segmentDistance > 0 
                        ? (targetDistance - distances[segmentIdx]) / segmentDistance 
                        : 0;
                    
                    const interpolatedLeft = current.left + (next.left - current.left) * segmentProgress;
                    cursor.style.left = interpolatedLeft + 'px';
                    cursor.style.top = current.top + 'px';
                }
                cursor.style.background = getComputedStyle(document.documentElement).getPropertyValue('--cursor-color').trim();
            }

            if (progress < 1) {
                requestAnimationFrame(updateCursorPosition);
            } else {
                // Animation complete
                setTimeout(() => {
                    currentSlokaIdx++;
                    renderSloka();
                }, 1000);
            }
        };

        requestAnimationFrame(updateCursorPosition);
    }

    function renderScrollMode() {
        const area = document.getElementById('displayArea');
        area.innerHTML = '';
        
        // Create single cursor for scroll mode
        const globalCursor = document.createElement('div');
        globalCursor.id = 'globalCursor';
        globalCursor.style.position = 'fixed';
        globalCursor.style.height = '6px';
        globalCursor.style.width = '35px';
        globalCursor.style.background = getComputedStyle(document.documentElement).getPropertyValue('--cursor-color').trim();
        globalCursor.style.borderRadius = '3px';
        globalCursor.style.zIndex = '100';
        globalCursor.style.pointerEvents = 'none';
        document.body.appendChild(globalCursor);

        const charSequence = [];

        slokas.forEach((sloka, sIdx) => {
            const container = document.createElement('div');
            container.className = 'sloka-container';
            container.id = `sloka-${sIdx}`;
            
            sloka.forEach((line, lIdx) => {
                const row = document.createElement('div');
                row.className = 'line-row';
                
                if (line.trim() === "") {
                    row.style.height = "1.5em";
                    container.appendChild(row);
                } else {
                    const segments = Array.from(segmenter.segment(line));
                    segments.forEach((seg, segIdx) => {
                        const span = document.createElement('span');
                        span.className = 'char-span';
                        span.id = `scroll-c-${sIdx}-${lIdx}-${segIdx}`;
                        span.textContent = seg.segment;
                        row.appendChild(span);
                        charSequence.push(span.id);
                    });
                    container.appendChild(row);
                }
            });
            area.appendChild(container);
        });

        setTimeout(() => {
            animateScrollCursor(charSequence);
        }, 100);
    }

    function animateScrollCursor(sequence) {
        if (!isReading || sequence.length === 0) {
            const cursor = document.getElementById('globalCursor');
            if (cursor) cursor.remove();
            return stopReading();
        }

        // Pre-calculate all character positions, only counting distances within lines
        const charPositions = [];
        const distances = [0];
        
        for (let i = 0; i < sequence.length; i++) {
            const charEl = document.getElementById(sequence[i]);
            if (charEl) {
                const charRect = charEl.getBoundingClientRect();
                charPositions.push({
                    left: charRect.left,
                    top: charRect.bottom - 4
                });
                
                if (i > 0) {
                    const prev = charPositions[i - 1];
                    const curr = charPositions[i];
                    
                    // Only count distance if on same line (Y difference < 5px)
                    if (Math.abs(curr.top - prev.top) <= 5) {
                        const dx = curr.left - prev.left;
                        const distance = Math.abs(dx);
                        distances.push(distances[i - 1] + distance);
                    } else {
                        // New line: distance resets to 0 (no wait at line beginning)
                        distances.push(distances[i - 1]);
                    }
                }
            }
        }

        if (charPositions.length === 0) {
            const cursor = document.getElementById('globalCursor');
            if (cursor) cursor.remove();
            return stopReading();
        }

        const totalDistance = distances[distances.length - 1];
        const speedValue = parseInt(document.getElementById('speedControl').value);
        const pixelsPerSecond = 100 * speedValue; // Higher speed value = faster movement
        const totalDuration = (totalDistance / pixelsPerSecond) * 1000; // in milliseconds
        const animationStartTime = performance.now();

        const updateCursorPosition = (currentTime) => {
            if (!isReading) return;

            const elapsed = currentTime - animationStartTime;
            const progress = Math.min(elapsed / totalDuration, 1);
            const targetDistance = progress * totalDistance;

            // Find which character segment we're in
            let segmentIdx = 0;
            for (let i = 0; i < distances.length - 1; i++) {
                if (targetDistance >= distances[i] && targetDistance < distances[i + 1]) {
                    segmentIdx = i;
                    break;
                }
            }
            if (targetDistance >= distances[distances.length - 1]) {
                segmentIdx = distances.length - 2;
            }

            const cursor = document.getElementById('globalCursor');
            if (cursor && charPositions.length > 0) {
                const nextIdx = Math.min(segmentIdx + 1, charPositions.length - 1);
                const current = charPositions[segmentIdx];
                const next = charPositions[nextIdx];
                
                // Check if crossing to a new line (instant vertical jump, no interpolation)
                const isNewLine = Math.abs(current.top - next.top) > 5;
                
                if (isNewLine) {
                    // Instantly jump to next line position, no wait
                    cursor.style.left = next.left + 'px';
                    cursor.style.top = next.top + 'px';
                } else {
                    // Same line - smooth horizontal interpolation only
                    const segmentDistance = distances[nextIdx] - distances[segmentIdx];
                    const segmentProgress = segmentDistance > 0 
                        ? (targetDistance - distances[segmentIdx]) / segmentDistance 
                        : 0;
                    
                    const interpolatedLeft = current.left + (next.left - current.left) * segmentProgress;
                    cursor.style.left = interpolatedLeft + 'px';
                    cursor.style.top = current.top + 'px';
                }
                cursor.style.background = getComputedStyle(document.documentElement).getPropertyValue('--cursor-color').trim();
            }

            if (progress < 1) {
                requestAnimationFrame(updateCursorPosition);
            } else {
                // Animation complete
                const cursor = document.getElementById('globalCursor');
                if (cursor) cursor.remove();
                stopReading();
            }
        };

        requestAnimationFrame(updateCursorPosition);
    }
    
    function stopReading() {
        log.info('Stopping reading session', { currentSloka: currentSlokaIdx, wasReading: isReading });
        
        isReading = false;
        clearTimeout(charTimeout);
        document.body.classList.remove('reading-active');
        document.getElementById('stopBtn').style.display = 'none';
        document.getElementById('displayArea').innerHTML = '';
        
        // Remove cursor element
        const cursor = document.getElementById('globalCursor');
        if (cursor) {
            cursor.remove();
            log.debug('Global cursor removed');
        }
        
        log.info('Reading session stopped successfully');
    }

    // Update font size in real-time with slider
    document.getElementById('fontSizeControl')?.addEventListener('input', (e) => {
        document.documentElement.style.setProperty('--font-size', e.target.value + 'px');
        document.getElementById('fontSizeValue').textContent = e.target.value;
        log.debug('Font size changed', { newSize: e.target.value });
    });

    // Update speed display
    document.getElementById('speedControl')?.addEventListener('input', (e) => {
        document.getElementById('speedValue').textContent = e.target.value;
        log.debug('Speed changed', { newSpeed: e.target.value });
    });

    // Update colors in real-time
    document.getElementById('bgPicker')?.addEventListener('input', (e) => {
        document.documentElement.style.setProperty('--bg-color', e.target.value);
        document.body.style.background = e.target.value;
        log.debug('Background color changed', { newColor: e.target.value });
    });

    document.getElementById('textPicker')?.addEventListener('input', (e) => {
        document.documentElement.style.setProperty('--text-color', e.target.value);
        document.body.style.color = e.target.value;
        log.debug('Text color changed', { newColor: e.target.value });
    });

    document.getElementById('cursorPicker')?.addEventListener('input', (e) => {
        document.documentElement.style.setProperty('--cursor-color', e.target.value);
        log.debug('Cursor color changed', { newColor: e.target.value });
    });

    // Set responsive defaults on page load
    window.addEventListener('DOMContentLoaded', () => {
        const width = window.innerWidth;
        let defaultFontSize = 42;
        
        if (width <= 480) {
            defaultFontSize = 22;
        } else if (width <= 768) {
            defaultFontSize = 28;
        }
        
        document.getElementById('fontSizeControl').value = defaultFontSize;
        document.getElementById('fontSizeValue').textContent = defaultFontSize;
        document.documentElement.style.setProperty('--font-size', defaultFontSize + 'px');
        
        log.info('Responsive defaults set', { screenWidth: width, fontSize: defaultFontSize });
    });

    // Register Service Worker for PWA functionality
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js')
                .then((registration) => {
                    log.info('Service Worker registered successfully', { scope: registration.scope });
                })
                .catch((error) => {
                    log.error('Service Worker registration failed', error);
                });
        });
    } else {
        log.warn('Service Worker not supported in this browser');
    }

</script>
</body>
</html>
